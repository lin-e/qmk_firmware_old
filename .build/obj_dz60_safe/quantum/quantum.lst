   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB110:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  64:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 64 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 73 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 74 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 75 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 76 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 77 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 78 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 80 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 83 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 85 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 87 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 89 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  90:quantum/quantum.c **** }
 106               		.loc 1 90 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  89:quantum/quantum.c **** }
 113               		.loc 1 89 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 90 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE110:
 127               		.section	.text.qk_register_weak_mods,"ax",@progbits
 129               	qk_register_weak_mods:
 130               	.LFB111:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 131               		.loc 1 92 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 93 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
  94:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 94 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE111:
 157               		.section	.text.qk_register_mods,"ax",@progbits
 159               	qk_register_mods:
 160               	.LFB113:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 161               		.loc 1 102 0
 162               		.cfi_startproc
 163               	.LVL16:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 168               		.loc 1 103 0
 169 0000 8770      		andi r24,lo8(7)
 170               	.LVL17:
 171 0002 91E0      		ldi r25,lo8(1)
 172 0004 00C0      		rjmp 2f
 173               		1:
 174 0006 990F      		lsl r25
 175               		2:
 176 0008 8A95      		dec r24
 177 000a 02F4      		brpl 1b
 178 000c 892F      		mov r24,r25
 179 000e 0E94 0000 		call add_weak_mods
 180               	.LVL18:
 104:quantum/quantum.c ****     send_keyboard_report();
 181               		.loc 1 104 0
 182 0012 0C94 0000 		jmp send_keyboard_report
 183               	.LVL19:
 184               		.cfi_endproc
 185               	.LFE113:
 187               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 189               	qk_unregister_weak_mods:
 190               	.LFB112:
  97:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 191               		.loc 1 97 0
 192               		.cfi_startproc
 193               	.LVL20:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
  98:quantum/quantum.c ****     send_keyboard_report();
 198               		.loc 1 98 0
 199 0000 8770      		andi r24,lo8(7)
 200               	.LVL21:
 201 0002 91E0      		ldi r25,lo8(1)
 202 0004 00C0      		rjmp 2f
 203               		1:
 204 0006 990F      		lsl r25
 205               		2:
 206 0008 8A95      		dec r24
 207 000a 02F4      		brpl 1b
 208 000c 892F      		mov r24,r25
 209 000e 0E94 0000 		call del_weak_mods
 210               	.LVL22:
  99:quantum/quantum.c **** }
 211               		.loc 1 99 0
 212 0012 0C94 0000 		jmp send_keyboard_report
 213               	.LVL23:
 214               		.cfi_endproc
 215               	.LFE112:
 217               		.section	.text.qk_unregister_mods,"ax",@progbits
 219               	qk_unregister_mods:
 220               	.LFB114:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 221               		.loc 1 107 0
 222               		.cfi_startproc
 223               	.LVL24:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 228               		.loc 1 108 0
 229 0000 8770      		andi r24,lo8(7)
 230               	.LVL25:
 231 0002 91E0      		ldi r25,lo8(1)
 232 0004 00C0      		rjmp 2f
 233               		1:
 234 0006 990F      		lsl r25
 235               		2:
 236 0008 8A95      		dec r24
 237 000a 02F4      		brpl 1b
 238 000c 892F      		mov r24,r25
 239 000e 0E94 0000 		call del_weak_mods
 240               	.LVL26:
 109:quantum/quantum.c ****     send_keyboard_report();
 241               		.loc 1 109 0
 242 0012 0C94 0000 		jmp send_keyboard_report
 243               	.LVL27:
 244               		.cfi_endproc
 245               	.LFE114:
 247               		.section	.text.register_code16,"ax",@progbits
 248               	.global	register_code16
 250               	register_code16:
 251               	.LFB115:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 252               		.loc 1 112 0
 253               		.cfi_startproc
 254               	.LVL28:
 255 0000 CF93      		push r28
 256               	.LCFI4:
 257               		.cfi_def_cfa_offset 3
 258               		.cfi_offset 28, -2
 259 0002 DF93      		push r29
 260               	.LCFI5:
 261               		.cfi_def_cfa_offset 4
 262               		.cfi_offset 29, -3
 263               	/* prologue: function */
 264               	/* frame size = 0 */
 265               	/* stack size = 2 */
 266               	.L__stack_usage = 2
 267 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 268               		.loc 1 113 0
 269 0006 805E      		subi r24,-32
 270 0008 9109      		sbc r25,__zero_reg__
 271               	.LVL29:
 272 000a 0897      		sbiw r24,8
 273 000c 00F0      		brlo .L28
 274               		.loc 1 113 0 is_stmt 0 discriminator 1
 275 000e 2097      		sbiw r28,0
 276 0010 01F4      		brne .L29
 277               	.L28:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 278               		.loc 1 114 0 is_stmt 1
 279 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 280 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 281 0016 00C0      		rjmp .L31
 282               	.L29:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 283               		.loc 1 116 0
 284 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 285 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 286               	.L31:
 287 001c CE01      		movw r24,r28
 288 001e 0E94 0000 		call do_code16
 289               	.LVL30:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 290               		.loc 1 118 0
 291 0022 8C2F      		mov r24,r28
 292               	/* epilogue start */
 119:quantum/quantum.c **** }
 293               		.loc 1 119 0
 294 0024 DF91      		pop r29
 295 0026 CF91      		pop r28
 296               	.LVL31:
 118:quantum/quantum.c **** }
 297               		.loc 1 118 0
 298 0028 0C94 0000 		jmp register_code
 299               	.LVL32:
 300               		.cfi_endproc
 301               	.LFE115:
 303               		.section	.text.unregister_code16,"ax",@progbits
 304               	.global	unregister_code16
 306               	unregister_code16:
 307               	.LFB116:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 308               		.loc 1 121 0
 309               		.cfi_startproc
 310               	.LVL33:
 311 0000 CF93      		push r28
 312               	.LCFI6:
 313               		.cfi_def_cfa_offset 3
 314               		.cfi_offset 28, -2
 315 0002 DF93      		push r29
 316               	.LCFI7:
 317               		.cfi_def_cfa_offset 4
 318               		.cfi_offset 29, -3
 319               	/* prologue: function */
 320               	/* frame size = 0 */
 321               	/* stack size = 2 */
 322               	.L__stack_usage = 2
 323 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 324               		.loc 1 122 0
 325 0006 0E94 0000 		call unregister_code
 326               	.LVL34:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 327               		.loc 1 123 0
 328 000a CE01      		movw r24,r28
 329 000c 805E      		subi r24,-32
 330 000e 9109      		sbc r25,__zero_reg__
 331 0010 0897      		sbiw r24,8
 332 0012 00F0      		brlo .L33
 333               		.loc 1 123 0 is_stmt 0 discriminator 1
 334 0014 2097      		sbiw r28,0
 335 0016 01F4      		brne .L34
 336               	.L33:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 337               		.loc 1 124 0 is_stmt 1
 338 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 339 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 340 001c 00C0      		rjmp .L35
 341               	.L34:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 342               		.loc 1 126 0
 343 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 344 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 345               	.L35:
 346 0022 CE01      		movw r24,r28
 347               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 348               		.loc 1 128 0
 349 0024 DF91      		pop r29
 350 0026 CF91      		pop r28
 351               	.LVL35:
 126:quantum/quantum.c ****   }
 352               		.loc 1 126 0
 353 0028 0C94 0000 		jmp do_code16
 354               	.LVL36:
 355               		.cfi_endproc
 356               	.LFE116:
 358               		.section	.text.process_action_kb,"ax",@progbits
 359               		.weak	process_action_kb
 361               	process_action_kb:
 362               	.LFB117:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 363               		.loc 1 131 0
 364               		.cfi_startproc
 365               	.LVL37:
 366               	/* prologue: function */
 367               	/* frame size = 0 */
 368               	/* stack size = 0 */
 369               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 370               		.loc 1 133 0
 371 0000 81E0      		ldi r24,lo8(1)
 372               	.LVL38:
 373 0002 0895      		ret
 374               		.cfi_endproc
 375               	.LFE117:
 377               		.section	.text.process_record_user,"ax",@progbits
 378               		.weak	process_record_user
 380               	process_record_user:
 381               	.LFB119:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 382               		.loc 1 141 0
 383               		.cfi_startproc
 384               	.LVL39:
 385               	/* prologue: function */
 386               	/* frame size = 0 */
 387               	/* stack size = 0 */
 388               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 389               		.loc 1 143 0
 390 0000 81E0      		ldi r24,lo8(1)
 391               	.LVL40:
 392 0002 0895      		ret
 393               		.cfi_endproc
 394               	.LFE119:
 396               		.section	.text.process_record_kb,"ax",@progbits
 397               		.weak	process_record_kb
 399               	process_record_kb:
 400               	.LFB118:
 136:quantum/quantum.c ****   return process_record_user(keycode, record);
 401               		.loc 1 136 0
 402               		.cfi_startproc
 403               	.LVL41:
 404               	/* prologue: function */
 405               	/* frame size = 0 */
 406               	/* stack size = 0 */
 407               	.L__stack_usage = 0
 137:quantum/quantum.c **** }
 408               		.loc 1 137 0
 409 0000 0C94 0000 		jmp process_record_user
 410               	.LVL42:
 411               		.cfi_endproc
 412               	.LFE118:
 414               		.section	.text.reset_keyboard,"ax",@progbits
 415               	.global	reset_keyboard
 417               	reset_keyboard:
 418               	.LFB120:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 419               		.loc 1 145 0
 420               		.cfi_startproc
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 425               		.loc 1 146 0
 426 0000 0E94 0000 		call clear_keyboard
 427               	.LVL43:
 428               	.LBB32:
 429               	.LBB33:
 430               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 431               		.loc 2 163 0
 432 0004 2FEF      		ldi r18,lo8(799999)
 433 0006 84E3      		ldi r24,hi8(799999)
 434 0008 9CE0      		ldi r25,hlo8(799999)
 435 000a 2150      	1:	subi r18,1
 436 000c 8040      		sbci r24,0
 437 000e 9040      		sbci r25,0
 438 0010 01F4      		brne 1b
 439 0012 00C0      		rjmp .
 440 0014 0000      		nop
 441               	.LBE33:
 442               	.LBE32:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 443               		.loc 1 165 0
 444 0016 0C94 0000 		jmp bootloader_jump
 445               	.LVL44:
 446               		.cfi_endproc
 447               	.LFE120:
 449               		.section	.text.process_record_quantum,"ax",@progbits
 450               	.global	process_record_quantum
 452               	process_record_quantum:
 453               	.LFB121:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 454               		.loc 1 190 0
 455               		.cfi_startproc
 456               	.LVL45:
 457 0000 FF92      		push r15
 458               	.LCFI8:
 459               		.cfi_def_cfa_offset 3
 460               		.cfi_offset 15, -2
 461 0002 0F93      		push r16
 462               	.LCFI9:
 463               		.cfi_def_cfa_offset 4
 464               		.cfi_offset 16, -3
 465 0004 1F93      		push r17
 466               	.LCFI10:
 467               		.cfi_def_cfa_offset 5
 468               		.cfi_offset 17, -4
 469 0006 CF93      		push r28
 470               	.LCFI11:
 471               		.cfi_def_cfa_offset 6
 472               		.cfi_offset 28, -5
 473 0008 DF93      		push r29
 474               	.LCFI12:
 475               		.cfi_def_cfa_offset 7
 476               		.cfi_offset 29, -6
 477               	/* prologue: function */
 478               	/* frame size = 0 */
 479               	/* stack size = 5 */
 480               	.L__stack_usage = 5
 481 000a 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 482               		.loc 1 193 0
 483 000c FC01      		movw r30,r24
 484 000e C081      		ld r28,Z
 485 0010 D181      		ldd r29,Z+1
 486               	.LVL46:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 487               		.loc 1 198 0
 488 0012 8091 0000 		lds r24,disable_action_cache
 489               	.LVL47:
 490 0016 8111      		cpse r24,__zero_reg__
 491 0018 00C0      		rjmp .L41
 492               	.LBB34:
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 493               		.loc 1 201 0
 494 001a 8281      		ldd r24,Z+2
 495 001c 8823      		tst r24
 496 001e 01F0      		breq .L42
 497               	.LVL48:
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 498               		.loc 1 202 0
 499 0020 CE01      		movw r24,r28
 500 0022 0E94 0000 		call layer_switch_get_layer
 501               	.LVL49:
 502 0026 F82E      		mov r15,r24
 503               	.LVL50:
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 504               		.loc 1 203 0
 505 0028 682F      		mov r22,r24
 506 002a CE01      		movw r24,r28
 507 002c 0E94 0000 		call update_source_layers_cache
 508               	.LVL51:
 509 0030 00C0      		rjmp .L43
 510               	.LVL52:
 511               	.L42:
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 512               		.loc 1 205 0
 513 0032 CE01      		movw r24,r28
 514 0034 0E94 0000 		call read_source_layers_cache
 515               	.LVL53:
 516 0038 F82E      		mov r15,r24
 517               	.LVL54:
 518               	.L43:
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 519               		.loc 1 207 0
 520 003a BE01      		movw r22,r28
 521 003c 8F2D      		mov r24,r15
 522 003e 00C0      		rjmp .L204
 523               	.LVL55:
 524               	.L41:
 525               	.LBE34:
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 526               		.loc 1 210 0
 527 0040 CE01      		movw r24,r28
 528 0042 0E94 0000 		call layer_switch_get_layer
 529               	.LVL56:
 530 0046 BE01      		movw r22,r28
 531               	.L204:
 532 0048 0E94 0000 		call keymap_key_to_keycode
 533               	.LVL57:
 534 004c EC01      		movw r28,r24
 535               	.LVL58:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 536               		.loc 1 229 0
 537 004e B801      		movw r22,r16
 538 0050 0E94 0000 		call process_record_kb
 539               	.LVL59:
 540 0054 8823      		tst r24
 541 0056 01F4      		brne .+2
 542 0058 00C0      		rjmp .L153
 230:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 231:quantum/quantum.c ****     process_midi(keycode, record) &&
 232:quantum/quantum.c ****   #endif
 233:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 234:quantum/quantum.c ****     process_audio(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #ifdef STENO_ENABLE
 237:quantum/quantum.c ****     process_steno(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 240:quantum/quantum.c ****     process_music(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 243:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 246:quantum/quantum.c ****     process_leader(keycode, record) &&
 543               		.loc 1 246 0 discriminator 2
 544 005a B801      		movw r22,r16
 545 005c CE01      		movw r24,r28
 546 005e 0E94 0000 		call process_leader
 547               	.LVL60:
 229:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 548               		.loc 1 229 0 discriminator 2
 549 0062 8823      		tst r24
 550 0064 01F4      		brne .+2
 551 0066 00C0      		rjmp .L153
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 249:quantum/quantum.c ****     process_chording(keycode, record) &&
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 252:quantum/quantum.c ****     process_combo(keycode, record) &&
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 255:quantum/quantum.c ****     process_unicode(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 258:quantum/quantum.c ****     process_ucis(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 261:quantum/quantum.c ****     process_printer(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 264:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 267:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 270:quantum/quantum.c ****     process_terminal(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****       true)) {
 273:quantum/quantum.c ****     return false;
 274:quantum/quantum.c ****   }
 275:quantum/quantum.c **** 
 276:quantum/quantum.c ****   // Shift / paren setup
 277:quantum/quantum.c **** 
 278:quantum/quantum.c ****   switch(keycode) {
 552               		.loc 1 278 0
 553 0068 C23C      		cpi r28,-62
 554 006a FCE5      		ldi r31,92
 555 006c DF07      		cpc r29,r31
 556 006e 01F4      		brne .L212
 279:quantum/quantum.c ****     case RESET:
 280:quantum/quantum.c ****       if (record->event.pressed) {
 281:quantum/quantum.c ****         reset_keyboard();
 282:quantum/quantum.c ****       }
 283:quantum/quantum.c ****     return false;
 284:quantum/quantum.c ****     case DEBUG:
 285:quantum/quantum.c ****       if (record->event.pressed) {
 286:quantum/quantum.c ****           debug_enable = true;
 287:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 291:quantum/quantum.c ****   case FC_TOG:
 292:quantum/quantum.c ****     if (record->event.pressed) {
 293:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 294:quantum/quantum.c ****     }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   case FC_ON:
 297:quantum/quantum.c ****     if (record->event.pressed) {
 298:quantum/quantum.c ****       FAUXCLICKY_ON;
 299:quantum/quantum.c ****     }
 300:quantum/quantum.c ****     return false;
 301:quantum/quantum.c ****   case FC_OFF:
 302:quantum/quantum.c ****     if (record->event.pressed) {
 303:quantum/quantum.c ****       FAUXCLICKY_OFF;
 304:quantum/quantum.c ****     }
 305:quantum/quantum.c ****     return false;
 306:quantum/quantum.c ****   #endif
 307:quantum/quantum.c ****   #ifdef RGBLIGHT_ENABLE
 308:quantum/quantum.c ****   case RGB_TOG:
 309:quantum/quantum.c ****     if (record->event.pressed) {
 310:quantum/quantum.c ****       rgblight_toggle();
 311:quantum/quantum.c ****     }
 312:quantum/quantum.c ****     return false;
 313:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 314:quantum/quantum.c ****     if (record->event.pressed) {
 315:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 316:quantum/quantum.c ****       if(shifted) {
 317:quantum/quantum.c ****         rgblight_step_reverse();
 318:quantum/quantum.c ****       }
 319:quantum/quantum.c ****       else {
 320:quantum/quantum.c ****         rgblight_step();
 321:quantum/quantum.c ****       }
 322:quantum/quantum.c ****     }
 323:quantum/quantum.c ****     return false;
 324:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 325:quantum/quantum.c ****     if (record->event.pressed) {
 326:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 327:quantum/quantum.c ****       if(shifted) {
 328:quantum/quantum.c ****         rgblight_step();
 329:quantum/quantum.c ****       }
 330:quantum/quantum.c ****       else {
 331:quantum/quantum.c ****         rgblight_step_reverse();
 332:quantum/quantum.c ****       }
 333:quantum/quantum.c ****     }
 334:quantum/quantum.c ****     return false;
 335:quantum/quantum.c ****   case RGB_HUI:
 336:quantum/quantum.c ****     if (record->event.pressed) {
 337:quantum/quantum.c ****       rgblight_increase_hue();
 338:quantum/quantum.c ****     }
 339:quantum/quantum.c ****     return false;
 340:quantum/quantum.c ****   case RGB_HUD:
 341:quantum/quantum.c ****     if (record->event.pressed) {
 342:quantum/quantum.c ****       rgblight_decrease_hue();
 343:quantum/quantum.c ****     }
 344:quantum/quantum.c ****     return false;
 345:quantum/quantum.c ****   case RGB_SAI:
 346:quantum/quantum.c ****     if (record->event.pressed) {
 347:quantum/quantum.c ****       rgblight_increase_sat();
 348:quantum/quantum.c ****     }
 349:quantum/quantum.c ****     return false;
 350:quantum/quantum.c ****   case RGB_SAD:
 351:quantum/quantum.c ****     if (record->event.pressed) {
 352:quantum/quantum.c ****       rgblight_decrease_sat();
 353:quantum/quantum.c ****     }
 354:quantum/quantum.c ****     return false;
 355:quantum/quantum.c ****   case RGB_VAI:
 356:quantum/quantum.c ****     if (record->event.pressed) {
 357:quantum/quantum.c ****       rgblight_increase_val();
 358:quantum/quantum.c ****     }
 359:quantum/quantum.c ****     return false;
 360:quantum/quantum.c ****   case RGB_VAD:
 361:quantum/quantum.c ****     if (record->event.pressed) {
 557               		.loc 1 361 0
 558 0070 F801      		movw r30,r16
 559 0072 8281      		ldd r24,Z+2
 560 0074 8823      		tst r24
 561 0076 01F4      		brne .+2
 562 0078 00C0      		rjmp .L153
 362:quantum/quantum.c ****       rgblight_decrease_val();
 563               		.loc 1 362 0
 564 007a 0E94 0000 		call rgblight_decrease_val
 565               	.LVL61:
 566 007e 00C0      		rjmp .L153
 567               	.L212:
 278:quantum/quantum.c ****     case RESET:
 568               		.loc 1 278 0
 569 0080 C33C      		cpi r28,-61
 570 0082 8CE5      		ldi r24,92
 571 0084 D807      		cpc r29,r24
 572 0086 00F0      		brlo .+2
 573 0088 00C0      		rjmp .L120
 574 008a CB3B      		cpi r28,-69
 575 008c 9CE5      		ldi r25,92
 576 008e D907      		cpc r29,r25
 577 0090 01F4      		brne .L213
 314:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 578               		.loc 1 314 0
 579 0092 F801      		movw r30,r16
 580 0094 8281      		ldd r24,Z+2
 581 0096 8823      		tst r24
 582 0098 01F4      		brne .+2
 583 009a 00C0      		rjmp .L153
 584               	.LBB35:
 315:quantum/quantum.c ****       if(shifted) {
 585               		.loc 1 315 0
 586 009c 0E94 0000 		call get_mods
 587               	.LVL62:
 588 00a0 8272      		andi r24,lo8(34)
 589               	.LVL63:
 316:quantum/quantum.c ****         rgblight_step_reverse();
 590               		.loc 1 316 0
 591 00a2 01F0      		breq .L52
 592               	.LVL64:
 593               	.L54:
 317:quantum/quantum.c ****       }
 594               		.loc 1 317 0
 595 00a4 0E94 0000 		call rgblight_step_reverse
 596               	.LVL65:
 597 00a8 00C0      		rjmp .L153
 598               	.L213:
 599               	.LBE35:
 278:quantum/quantum.c ****     case RESET:
 600               		.loc 1 278 0
 601 00aa CC3B      		cpi r28,-68
 602 00ac ECE5      		ldi r30,92
 603 00ae DE07      		cpc r29,r30
 604 00b0 00F0      		brlo .L214
 605 00b2 CE3B      		cpi r28,-66
 606 00b4 9CE5      		ldi r25,92
 607 00b6 D907      		cpc r29,r25
 608 00b8 01F4      		brne .+2
 609 00ba 00C0      		rjmp .L56
 610 00bc 00F0      		brlo .+2
 611 00be 00C0      		rjmp .L123
 612 00c0 CC3B      		cpi r28,-68
 613 00c2 FCE5      		ldi r31,92
 614 00c4 DF07      		cpc r29,r31
 615 00c6 01F0      		breq .+2
 616 00c8 00C0      		rjmp .L215
 325:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 617               		.loc 1 325 0
 618 00ca F801      		movw r30,r16
 619 00cc 8281      		ldd r24,Z+2
 620 00ce 8823      		tst r24
 621 00d0 01F4      		brne .+2
 622 00d2 00C0      		rjmp .L153
 623               	.LBB36:
 326:quantum/quantum.c ****       if(shifted) {
 624               		.loc 1 326 0
 625 00d4 0E94 0000 		call get_mods
 626               	.LVL66:
 627 00d8 8272      		andi r24,lo8(34)
 628               	.LVL67:
 327:quantum/quantum.c ****         rgblight_step();
 629               		.loc 1 327 0
 630 00da 01F0      		breq .L54
 631               	.LVL68:
 632               	.L52:
 633               	.LBE36:
 634               	.LBB37:
 320:quantum/quantum.c ****       }
 635               		.loc 1 320 0
 636 00dc 0E94 0000 		call rgblight_step
 637               	.LVL69:
 638 00e0 00C0      		rjmp .L153
 639               	.L214:
 640               	.LBE37:
 278:quantum/quantum.c ****     case RESET:
 641               		.loc 1 278 0
 642 00e2 C531      		cpi r28,21
 643 00e4 FCE5      		ldi r31,92
 644 00e6 DF07      		cpc r29,r31
 645 00e8 00F0      		brlo .+2
 646 00ea 00C0      		rjmp .L122
 647 00ec C230      		cpi r28,2
 648 00ee 8CE5      		ldi r24,92
 649 00f0 D807      		cpc r29,r24
 650 00f2 00F4      		brsh .+2
 651 00f4 00C0      		rjmp .L216
 363:quantum/quantum.c ****     }
 364:quantum/quantum.c ****     return false;
 365:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 366:quantum/quantum.c ****     if (record->event.pressed) {
 367:quantum/quantum.c ****       rgblight_mode(1);
 368:quantum/quantum.c ****     }
 369:quantum/quantum.c ****     return false;
 370:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 371:quantum/quantum.c ****     if (record->event.pressed) {
 372:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 373:quantum/quantum.c ****         rgblight_step();
 374:quantum/quantum.c ****       } else {
 375:quantum/quantum.c ****         rgblight_mode(2);
 376:quantum/quantum.c ****       }
 377:quantum/quantum.c ****     }
 378:quantum/quantum.c ****     return false;
 379:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 380:quantum/quantum.c ****     if (record->event.pressed) {
 381:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 382:quantum/quantum.c ****         rgblight_step();
 383:quantum/quantum.c ****       } else {
 384:quantum/quantum.c ****         rgblight_mode(6);
 385:quantum/quantum.c ****       }
 386:quantum/quantum.c ****     }
 387:quantum/quantum.c ****     return false;
 388:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 389:quantum/quantum.c ****     if (record->event.pressed) {
 390:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 391:quantum/quantum.c ****         rgblight_step();
 392:quantum/quantum.c ****       } else {
 393:quantum/quantum.c ****         rgblight_mode(9);
 394:quantum/quantum.c ****       }
 395:quantum/quantum.c ****     }
 396:quantum/quantum.c ****     return false;
 397:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 398:quantum/quantum.c ****     if (record->event.pressed) {
 399:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 400:quantum/quantum.c ****         rgblight_step();
 401:quantum/quantum.c ****       } else {
 402:quantum/quantum.c ****         rgblight_mode(15);
 403:quantum/quantum.c ****       }
 404:quantum/quantum.c ****     }
 405:quantum/quantum.c ****     return false;
 406:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 407:quantum/quantum.c ****     if (record->event.pressed) {
 408:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 409:quantum/quantum.c ****         rgblight_step();
 410:quantum/quantum.c ****       } else {
 411:quantum/quantum.c ****         rgblight_mode(21);
 412:quantum/quantum.c ****       }
 413:quantum/quantum.c ****     }
 414:quantum/quantum.c ****     return false;
 415:quantum/quantum.c ****   case RGB_MODE_XMAS:
 416:quantum/quantum.c ****     if (record->event.pressed) {
 417:quantum/quantum.c ****       rgblight_mode(24);
 418:quantum/quantum.c ****     }
 419:quantum/quantum.c ****     return false;
 420:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 421:quantum/quantum.c ****     if (record->event.pressed) {
 422:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 423:quantum/quantum.c ****         rgblight_step();
 424:quantum/quantum.c ****       } else {
 425:quantum/quantum.c ****         rgblight_mode(25);
 426:quantum/quantum.c ****       }
 427:quantum/quantum.c ****     }
 428:quantum/quantum.c ****     return false;
 429:quantum/quantum.c ****   #endif
 430:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 431:quantum/quantum.c ****     case OUT_AUTO:
 432:quantum/quantum.c ****       if (record->event.pressed) {
 433:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 434:quantum/quantum.c ****       }
 435:quantum/quantum.c ****       return false;
 436:quantum/quantum.c ****     case OUT_USB:
 437:quantum/quantum.c ****       if (record->event.pressed) {
 438:quantum/quantum.c ****         set_output(OUTPUT_USB);
 439:quantum/quantum.c ****       }
 440:quantum/quantum.c ****       return false;
 441:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 442:quantum/quantum.c ****     case OUT_BT:
 443:quantum/quantum.c ****       if (record->event.pressed) {
 444:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 445:quantum/quantum.c ****       }
 446:quantum/quantum.c ****       return false;
 447:quantum/quantum.c ****     #endif
 448:quantum/quantum.c ****     #endif
 449:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 450:quantum/quantum.c ****       if (record->event.pressed) {
 652               		.loc 1 450 0
 653 00f6 F801      		movw r30,r16
 654 00f8 8281      		ldd r24,Z+2
 655 00fa 8823      		tst r24
 656 00fc 01F4      		brne .+2
 657 00fe 00C0      		rjmp .L78
 451:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 452:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 658               		.loc 1 452 0
 659 0100 0E94 0000 		call eeconfig_is_enabled
 660               	.LVL70:
 661 0104 8111      		cpse r24,__zero_reg__
 662 0106 00C0      		rjmp .L79
 453:quantum/quantum.c ****             eeconfig_init();
 663               		.loc 1 453 0
 664 0108 0E94 0000 		call eeconfig_init
 665               	.LVL71:
 666               	.L79:
 454:quantum/quantum.c ****         }
 455:quantum/quantum.c ****         /* keymap config */
 456:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 667               		.loc 1 456 0
 668 010c 0E94 0000 		call eeconfig_read_keymap
 669               	.LVL72:
 670 0110 90E0      		ldi r25,0
 671 0112 9093 0000 		sts keymap_config+1,r25
 672 0116 8093 0000 		sts keymap_config,r24
 457:quantum/quantum.c ****         switch (keycode)
 673               		.loc 1 457 0
 674 011a FE01      		movw r30,r28
 675 011c E350      		subi r30,3
 676 011e FC45      		sbci r31,92
 677 0120 E231      		cpi r30,18
 678 0122 F105      		cpc r31,__zero_reg__
 679 0124 00F4      		brsh .L80
 680 0126 E050      		subi r30,lo8(-(gs(.L82)))
 681 0128 F040      		sbci r31,hi8(-(gs(.L82)))
 458:quantum/quantum.c ****         {
 459:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 460:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 461:quantum/quantum.c ****             break;
 462:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 463:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 464:quantum/quantum.c ****             break;
 465:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 466:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 467:quantum/quantum.c ****             break;
 468:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 469:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 470:quantum/quantum.c ****             break;
 471:quantum/quantum.c ****           case MAGIC_NO_GUI:
 472:quantum/quantum.c ****             keymap_config.no_gui = true;
 473:quantum/quantum.c ****             break;
 474:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 475:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 476:quantum/quantum.c ****             break;
 477:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 478:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 479:quantum/quantum.c ****             break;
 480:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 481:quantum/quantum.c ****             keymap_config.nkro = true;
 482:quantum/quantum.c ****             break;
 483:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 484:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 487:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 488:quantum/quantum.c ****             #endif
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 491:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 494:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 497:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 500:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 501:quantum/quantum.c ****             break;
 502:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 503:quantum/quantum.c ****             keymap_config.no_gui = false;
 504:quantum/quantum.c ****             break;
 505:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 506:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 507:quantum/quantum.c ****             break;
 508:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 509:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 510:quantum/quantum.c ****             break;
 511:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 512:quantum/quantum.c ****             keymap_config.nkro = false;
 513:quantum/quantum.c ****             break;
 514:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 515:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 518:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 519:quantum/quantum.c ****             #endif
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 522:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 682               		.loc 1 522 0
 683 012a 8091 0000 		lds r24,keymap_config
 457:quantum/quantum.c ****         switch (keycode)
 684               		.loc 1 457 0
 685 012e 0C94 0000 		jmp __tablejump2__
 686               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 687               		.p2align	1
 688               	.L82:
 689 0000 0000      		.word gs(.L81)
 690 0002 0000      		.word gs(.L83)
 691 0004 0000      		.word gs(.L211)
 692 0006 0000      		.word gs(.L85)
 693 0008 0000      		.word gs(.L86)
 694 000a 0000      		.word gs(.L87)
 695 000c 0000      		.word gs(.L88)
 696 000e 0000      		.word gs(.L89)
 697 0010 0000      		.word gs(.L90)
 698 0012 0000      		.word gs(.L91)
 699 0014 0000      		.word gs(.L92)
 700 0016 0000      		.word gs(.L210)
 701 0018 0000      		.word gs(.L94)
 702 001a 0000      		.word gs(.L95)
 703 001c 0000      		.word gs(.L96)
 704 001e 0000      		.word gs(.L97)
 705 0020 0000      		.word gs(.L98)
 706 0022 0000      		.word gs(.L99)
 707               		.section	.text.process_record_quantum
 708               	.L80:
 460:quantum/quantum.c ****             break;
 709               		.loc 1 460 0
 710 0132 8091 0000 		lds r24,keymap_config
 711 0136 8160      		ori r24,lo8(1<<0)
 712 0138 00C0      		rjmp .L205
 713               	.L81:
 463:quantum/quantum.c ****             break;
 714               		.loc 1 463 0
 715 013a 8260      		ori r24,lo8(1<<1)
 716 013c 00C0      		rjmp .L205
 717               	.L83:
 466:quantum/quantum.c ****             break;
 718               		.loc 1 466 0
 719 013e 8460      		ori r24,lo8(1<<2)
 720 0140 00C0      		rjmp .L205
 721               	.L85:
 472:quantum/quantum.c ****             break;
 722               		.loc 1 472 0
 723 0142 8061      		ori r24,lo8(1<<4)
 724 0144 00C0      		rjmp .L205
 725               	.L86:
 475:quantum/quantum.c ****             break;
 726               		.loc 1 475 0
 727 0146 8062      		ori r24,lo8(1<<5)
 728 0148 00C0      		rjmp .L205
 729               	.L87:
 478:quantum/quantum.c ****             break;
 730               		.loc 1 478 0
 731 014a 8064      		ori r24,lo8(1<<6)
 732 014c 00C0      		rjmp .L205
 733               	.L88:
 481:quantum/quantum.c ****             break;
 734               		.loc 1 481 0
 735 014e 8068      		ori r24,lo8(1<<7)
 736 0150 00C0      		rjmp .L205
 737               	.L89:
 485:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 738               		.loc 1 485 0
 739 0152 8460      		ori r24,lo8(4)
 740               	.L211:
 741 0154 8860      		ori r24,lo8(1<<3)
 742 0156 00C0      		rjmp .L205
 743               	.L90:
 491:quantum/quantum.c ****             break;
 744               		.loc 1 491 0
 745 0158 8E7F      		andi r24,lo8(~(1<<0))
 746 015a 00C0      		rjmp .L205
 747               	.L91:
 494:quantum/quantum.c ****             break;
 748               		.loc 1 494 0
 749 015c 8D7F      		andi r24,lo8(~(1<<1))
 750 015e 00C0      		rjmp .L205
 751               	.L92:
 497:quantum/quantum.c ****             break;
 752               		.loc 1 497 0
 753 0160 8B7F      		andi r24,lo8(~(1<<2))
 754 0162 00C0      		rjmp .L205
 755               	.L94:
 503:quantum/quantum.c ****             break;
 756               		.loc 1 503 0
 757 0164 8F7E      		andi r24,lo8(~(1<<4))
 758 0166 00C0      		rjmp .L205
 759               	.L95:
 506:quantum/quantum.c ****             break;
 760               		.loc 1 506 0
 761 0168 8F7D      		andi r24,lo8(~(1<<5))
 762 016a 00C0      		rjmp .L205
 763               	.L96:
 509:quantum/quantum.c ****             break;
 764               		.loc 1 509 0
 765 016c 8F7B      		andi r24,lo8(~(1<<6))
 766 016e 00C0      		rjmp .L205
 767               	.L97:
 512:quantum/quantum.c ****             break;
 768               		.loc 1 512 0
 769 0170 8F77      		andi r24,lo8(~(1<<7))
 770 0172 00C0      		rjmp .L205
 771               	.L98:
 516:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 772               		.loc 1 516 0
 773 0174 8B7F      		andi r24,lo8(-5)
 774               	.L210:
 775 0176 877F      		andi r24,lo8(~(1<<3))
 776 0178 00C0      		rjmp .L205
 777               	.L99:
 778               		.loc 1 522 0
 779 017a 87FB      		bst r24,7
 780 017c 2227      		clr r18
 781 017e 20F9      		bld r18,0
 782 0180 91E0      		ldi r25,lo8(1)
 783 0182 9227      		eor r25,r18
 784 0184 90FB      		bst r25,0
 785 0186 87F9      		bld r24,7
 786               	.L205:
 787 0188 8093 0000 		sts keymap_config,r24
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           default:
 525:quantum/quantum.c ****             break;
 526:quantum/quantum.c ****         }
 527:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 788               		.loc 1 527 0
 789 018c 8091 0000 		lds r24,keymap_config
 790 0190 0E94 0000 		call eeconfig_update_keymap
 791               	.LVL73:
 528:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 792               		.loc 1 528 0
 793 0194 0E94 0000 		call clear_keyboard
 794               	.LVL74:
 529:quantum/quantum.c **** 
 530:quantum/quantum.c ****         return false;
 795               		.loc 1 530 0
 796 0198 00C0      		rjmp .L153
 797               	.L216:
 278:quantum/quantum.c ****     case RESET:
 798               		.loc 1 278 0
 799 019a C115      		cp r28,__zero_reg__
 800 019c 9CE5      		ldi r25,92
 801 019e D907      		cpc r29,r25
 802 01a0 01F0      		breq .L47
 803 01a2 C130      		cpi r28,1
 804 01a4 DC45      		sbci r29,92
 805 01a6 01F0      		breq .L49
 806               	.L119:
 531:quantum/quantum.c ****       }
 532:quantum/quantum.c ****       break;
 533:quantum/quantum.c ****     case KC_LSPO: {
 534:quantum/quantum.c ****       if (record->event.pressed) {
 535:quantum/quantum.c ****         shift_interrupted[0] = false;
 536:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 537:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 538:quantum/quantum.c ****       }
 539:quantum/quantum.c ****       else {
 540:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 541:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 542:quantum/quantum.c ****             shift_interrupted[0] = true;
 543:quantum/quantum.c ****             shift_interrupted[1] = true;
 544:quantum/quantum.c ****           }
 545:quantum/quantum.c ****         #endif
 546:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 547:quantum/quantum.c ****           register_code(LSPO_KEY);
 548:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 549:quantum/quantum.c ****         }
 550:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 551:quantum/quantum.c ****       }
 552:quantum/quantum.c ****       return false;
 553:quantum/quantum.c ****     }
 554:quantum/quantum.c **** 
 555:quantum/quantum.c ****     case KC_RSPC: {
 556:quantum/quantum.c ****       if (record->event.pressed) {
 557:quantum/quantum.c ****         shift_interrupted[1] = false;
 558:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 559:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 560:quantum/quantum.c ****       }
 561:quantum/quantum.c ****       else {
 562:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 563:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 564:quantum/quantum.c ****             shift_interrupted[0] = true;
 565:quantum/quantum.c ****             shift_interrupted[1] = true;
 566:quantum/quantum.c ****           }
 567:quantum/quantum.c ****         #endif
 568:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 569:quantum/quantum.c ****           register_code(RSPC_KEY);
 570:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 571:quantum/quantum.c ****         }
 572:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 573:quantum/quantum.c ****       }
 574:quantum/quantum.c ****       return false;
 575:quantum/quantum.c ****     }
 576:quantum/quantum.c **** 
 577:quantum/quantum.c ****     case KC_SFTENT: {
 578:quantum/quantum.c ****       if (record->event.pressed) {
 579:quantum/quantum.c ****         shift_interrupted[1] = false;
 580:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 581:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 582:quantum/quantum.c ****       }
 583:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 584:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 585:quantum/quantum.c ****         register_code(SFTENT_KEY);
 586:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 587:quantum/quantum.c ****       }
 588:quantum/quantum.c ****       else {
 589:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 590:quantum/quantum.c ****       }
 591:quantum/quantum.c ****       return false;
 592:quantum/quantum.c ****     }
 593:quantum/quantum.c **** 
 594:quantum/quantum.c ****     case GRAVE_ESC: {
 595:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 596:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 597:quantum/quantum.c **** 
 598:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 599:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 600:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 601:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 602:quantum/quantum.c ****         shifted = 0;
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c **** #endif
 605:quantum/quantum.c **** 
 606:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 607:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 608:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 609:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 610:quantum/quantum.c ****         shifted = 0;
 611:quantum/quantum.c ****       }
 612:quantum/quantum.c **** #endif
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 615:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 616:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 617:quantum/quantum.c ****         shifted = 0;
 618:quantum/quantum.c ****       }
 619:quantum/quantum.c **** #endif
 620:quantum/quantum.c **** 
 621:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 622:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 623:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 624:quantum/quantum.c ****         shifted = 0;
 625:quantum/quantum.c ****       }
 626:quantum/quantum.c **** #endif
 627:quantum/quantum.c **** 
 628:quantum/quantum.c ****       if (record->event.pressed) {
 629:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 630:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 631:quantum/quantum.c ****       }
 632:quantum/quantum.c ****       else {
 633:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** 
 636:quantum/quantum.c ****       send_keyboard_report();
 637:quantum/quantum.c ****       return false;
 638:quantum/quantum.c ****     }
 639:quantum/quantum.c **** 
 640:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 641:quantum/quantum.c ****     case BL_BRTG: {
 642:quantum/quantum.c ****       if (record->event.pressed)
 643:quantum/quantum.c ****         breathing_toggle();
 644:quantum/quantum.c ****       return false;
 645:quantum/quantum.c ****     }
 646:quantum/quantum.c **** #endif
 647:quantum/quantum.c **** 
 648:quantum/quantum.c ****     default: {
 649:quantum/quantum.c ****       shift_interrupted[0] = true;
 807               		.loc 1 649 0
 808 01a8 81E0      		ldi r24,lo8(1)
 809 01aa 8093 0000 		sts shift_interrupted,r24
 650:quantum/quantum.c ****       shift_interrupted[1] = true;
 810               		.loc 1 650 0
 811 01ae 8093 0000 		sts shift_interrupted+1,r24
 812               	.L78:
 651:quantum/quantum.c ****       break;
 652:quantum/quantum.c ****     }
 653:quantum/quantum.c ****   }
 654:quantum/quantum.c **** 
 655:quantum/quantum.c ****   return process_action_kb(record);
 813               		.loc 1 655 0
 814 01b2 C801      		movw r24,r16
 815               	/* epilogue start */
 656:quantum/quantum.c **** }
 816               		.loc 1 656 0
 817 01b4 DF91      		pop r29
 818 01b6 CF91      		pop r28
 819               	.LVL75:
 820 01b8 1F91      		pop r17
 821 01ba 0F91      		pop r16
 822               	.LVL76:
 823 01bc FF90      		pop r15
 655:quantum/quantum.c **** }
 824               		.loc 1 655 0
 825 01be 0C94 0000 		jmp process_action_kb
 826               	.LVL77:
 827               	.L47:
 280:quantum/quantum.c ****         reset_keyboard();
 828               		.loc 1 280 0
 829 01c2 F801      		movw r30,r16
 830 01c4 8281      		ldd r24,Z+2
 831 01c6 8823      		tst r24
 832 01c8 01F4      		brne .+2
 833 01ca 00C0      		rjmp .L153
 281:quantum/quantum.c ****       }
 834               		.loc 1 281 0
 835 01cc 0E94 0000 		call reset_keyboard
 836               	.LVL78:
 837 01d0 00C0      		rjmp .L153
 838               	.L49:
 285:quantum/quantum.c ****           debug_enable = true;
 839               		.loc 1 285 0
 840 01d2 F801      		movw r30,r16
 841 01d4 8281      		ldd r24,Z+2
 842 01d6 8823      		tst r24
 843 01d8 01F4      		brne .+2
 844 01da 00C0      		rjmp .L153
 286:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 845               		.loc 1 286 0
 846 01dc 8091 0000 		lds r24,debug_config
 847 01e0 8160      		ori r24,lo8(1<<0)
 848 01e2 8093 0000 		sts debug_config,r24
 849 01e6 00C0      		rjmp .L153
 850               	.L122:
 278:quantum/quantum.c ****     case RESET:
 851               		.loc 1 278 0
 852 01e8 C531      		cpi r28,21
 853 01ea FCE5      		ldi r31,92
 854 01ec DF07      		cpc r29,r31
 855 01ee 01F4      		brne .L217
 856               	.LBB38:
 595:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 857               		.loc 1 595 0
 858 01f0 0E94 0000 		call get_mods
 859               	.LVL79:
 860 01f4 282F      		mov r18,r24
 861               	.LVL80:
 628:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 862               		.loc 1 628 0
 863 01f6 F801      		movw r30,r16
 864 01f8 8281      		ldd r24,Z+2
 865 01fa 4091 0000 		lds r20,keyboard_report
 866 01fe 5091 0000 		lds r21,keyboard_report+1
 867 0202 8823      		tst r24
 868 0204 01F0      		breq .L114
 595:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 869               		.loc 1 595 0
 870 0206 2A7A      		andi r18,lo8(-86)
 871               	.LVL81:
 629:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 872               		.loc 1 629 0
 873 0208 91E0      		ldi r25,lo8(1)
 874 020a 01F4      		brne .L115
 875 020c 90E0      		ldi r25,0
 876               	.L115:
 877 020e 9093 0000 		sts grave_esc_was_shifted,r25
 630:quantum/quantum.c ****       }
 878               		.loc 1 630 0
 879 0212 9111      		cpse r25,__zero_reg__
 880 0214 00C0      		rjmp .L127
 881 0216 69E2      		ldi r22,lo8(41)
 882 0218 00C0      		rjmp .L116
 883               	.L127:
 884 021a 65E3      		ldi r22,lo8(53)
 885               	.L116:
 886               	.LVL82:
 887               	.LBB39:
 888               	.LBB40:
 889               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 890               		.loc 3 33 0 discriminator 4
 891 021c CA01      		movw r24,r20
 892 021e 0E94 0000 		call add_key_to_report
 893               	.LVL83:
 894 0222 00C0      		rjmp .L117
 895               	.LVL84:
 896               	.L114:
 897               	.LBE40:
 898               	.LBE39:
 633:quantum/quantum.c ****       }
 899               		.loc 1 633 0
 900 0224 8091 0000 		lds r24,grave_esc_was_shifted
 901 0228 8111      		cpse r24,__zero_reg__
 902 022a 00C0      		rjmp .L128
 903 022c 69E2      		ldi r22,lo8(41)
 904 022e 00C0      		rjmp .L118
 905               	.L128:
 906 0230 65E3      		ldi r22,lo8(53)
 907               	.L118:
 908               	.LVL85:
 909               	.LBB41:
 910               	.LBB42:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 911               		.loc 3 37 0 discriminator 4
 912 0232 CA01      		movw r24,r20
 913 0234 0E94 0000 		call del_key_from_report
 914               	.LVL86:
 915               	.L117:
 916               	.LBE42:
 917               	.LBE41:
 636:quantum/quantum.c ****       return false;
 918               		.loc 1 636 0
 919 0238 0E94 0000 		call send_keyboard_report
 920               	.LVL87:
 637:quantum/quantum.c ****     }
 921               		.loc 1 637 0
 922 023c 00C0      		rjmp .L153
 923               	.L217:
 924               	.LBE38:
 278:quantum/quantum.c ****     case RESET:
 925               		.loc 1 278 0
 926 023e CA3B      		cpi r28,-70
 927 0240 DC45      		sbci r29,92
 928 0242 01F0      		breq .+2
 929 0244 00C0      		rjmp .L119
 309:quantum/quantum.c ****       rgblight_toggle();
 930               		.loc 1 309 0
 931 0246 F801      		movw r30,r16
 932 0248 8281      		ldd r24,Z+2
 933 024a 8823      		tst r24
 934 024c 01F4      		brne .+2
 935 024e 00C0      		rjmp .L153
 310:quantum/quantum.c ****     }
 936               		.loc 1 310 0
 937 0250 0E94 0000 		call rgblight_toggle
 938               	.LVL88:
 939 0254 00C0      		rjmp .L153
 940               	.L56:
 341:quantum/quantum.c ****       rgblight_decrease_hue();
 941               		.loc 1 341 0
 942 0256 F801      		movw r30,r16
 943 0258 8281      		ldd r24,Z+2
 944 025a 8823      		tst r24
 945 025c 01F4      		brne .+2
 946 025e 00C0      		rjmp .L153
 342:quantum/quantum.c ****     }
 947               		.loc 1 342 0
 948 0260 0E94 0000 		call rgblight_decrease_hue
 949               	.LVL89:
 950 0264 00C0      		rjmp .L153
 951               	.L215:
 278:quantum/quantum.c ****     case RESET:
 952               		.loc 1 278 0
 953 0266 CD3B      		cpi r28,-67
 954 0268 DC45      		sbci r29,92
 955 026a 01F0      		breq .+2
 956 026c 00C0      		rjmp .L119
 336:quantum/quantum.c ****       rgblight_increase_hue();
 957               		.loc 1 336 0
 958 026e F801      		movw r30,r16
 959 0270 8281      		ldd r24,Z+2
 960 0272 8823      		tst r24
 961 0274 01F4      		brne .+2
 962 0276 00C0      		rjmp .L153
 337:quantum/quantum.c ****     }
 963               		.loc 1 337 0
 964 0278 0E94 0000 		call rgblight_increase_hue
 965               	.LVL90:
 966 027c 00C0      		rjmp .L153
 967               	.L123:
 968 027e F801      		movw r30,r16
 969 0280 8281      		ldd r24,Z+2
 278:quantum/quantum.c ****     case RESET:
 970               		.loc 1 278 0
 971 0282 C03C      		cpi r28,-64
 972 0284 FCE5      		ldi r31,92
 973 0286 DF07      		cpc r29,r31
 974 0288 01F4      		brne .L218
 351:quantum/quantum.c ****       rgblight_decrease_sat();
 975               		.loc 1 351 0
 976 028a 8823      		tst r24
 977 028c 01F4      		brne .+2
 978 028e 00C0      		rjmp .L153
 352:quantum/quantum.c ****     }
 979               		.loc 1 352 0
 980 0290 0E94 0000 		call rgblight_decrease_sat
 981               	.LVL91:
 982 0294 00C0      		rjmp .L153
 983               	.L218:
 278:quantum/quantum.c ****     case RESET:
 984               		.loc 1 278 0
 985 0296 C13C      		cpi r28,-63
 986 0298 DC45      		sbci r29,92
 987 029a 00F4      		brsh .L219
 346:quantum/quantum.c ****       rgblight_increase_sat();
 988               		.loc 1 346 0
 989 029c 8823      		tst r24
 990 029e 01F4      		brne .+2
 991 02a0 00C0      		rjmp .L153
 347:quantum/quantum.c ****     }
 992               		.loc 1 347 0
 993 02a2 0E94 0000 		call rgblight_increase_sat
 994               	.LVL92:
 995 02a6 00C0      		rjmp .L153
 996               	.L219:
 356:quantum/quantum.c ****       rgblight_increase_val();
 997               		.loc 1 356 0
 998 02a8 8823      		tst r24
 999 02aa 01F4      		brne .+2
 1000 02ac 00C0      		rjmp .L153
 357:quantum/quantum.c ****     }
 1001               		.loc 1 357 0
 1002 02ae 0E94 0000 		call rgblight_increase_val
 1003               	.LVL93:
 1004 02b2 00C0      		rjmp .L153
 1005               	.L120:
 278:quantum/quantum.c ****     case RESET:
 1006               		.loc 1 278 0
 1007 02b4 C93C      		cpi r28,-55
 1008 02b6 ECE5      		ldi r30,92
 1009 02b8 DE07      		cpc r29,r30
 1010 02ba 01F4      		brne .L220
 416:quantum/quantum.c ****       rgblight_mode(24);
 1011               		.loc 1 416 0
 1012 02bc F801      		movw r30,r16
 1013 02be 8281      		ldd r24,Z+2
 1014 02c0 8823      		tst r24
 1015 02c2 01F4      		brne .+2
 1016 02c4 00C0      		rjmp .L153
 417:quantum/quantum.c ****     }
 1017               		.loc 1 417 0
 1018 02c6 88E1      		ldi r24,lo8(24)
 1019               	.L206:
 375:quantum/quantum.c ****       }
 1020               		.loc 1 375 0
 1021 02c8 0E94 0000 		call rgblight_mode
 1022               	.LVL94:
 1023 02cc 00C0      		rjmp .L153
 1024               	.L220:
 278:quantum/quantum.c ****     case RESET:
 1025               		.loc 1 278 0
 1026 02ce CA3C      		cpi r28,-54
 1027 02d0 FCE5      		ldi r31,92
 1028 02d2 DF07      		cpc r29,r31
 1029 02d4 00F0      		brlo .+2
 1030 02d6 00C0      		rjmp .L124
 1031 02d8 C53C      		cpi r28,-59
 1032 02da 8CE5      		ldi r24,92
 1033 02dc D807      		cpc r29,r24
 1034 02de 01F4      		brne .L221
 380:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1035               		.loc 1 380 0
 1036 02e0 F801      		movw r30,r16
 1037 02e2 8281      		ldd r24,Z+2
 1038 02e4 8823      		tst r24
 1039 02e6 01F4      		brne .+2
 1040 02e8 00C0      		rjmp .L153
 381:quantum/quantum.c ****         rgblight_step();
 1041               		.loc 1 381 0
 1042 02ea 0E94 0000 		call rgblight_get_mode
 1043               	.LVL95:
 1044 02ee 6630      		cpi r22,6
 1045 02f0 7105      		cpc r23,__zero_reg__
 1046 02f2 8105      		cpc r24,__zero_reg__
 1047 02f4 9105      		cpc r25,__zero_reg__
 1048 02f6 00F0      		brlo .L65
 381:quantum/quantum.c ****         rgblight_step();
 1049               		.loc 1 381 0 is_stmt 0 discriminator 1
 1050 02f8 0E94 0000 		call rgblight_get_mode
 1051               	.LVL96:
 1052 02fc 6830      		cpi r22,8
 1053 02fe 7105      		cpc r23,__zero_reg__
 1054 0300 8105      		cpc r24,__zero_reg__
 1055 0302 9105      		cpc r25,__zero_reg__
 1056 0304 00F4      		brsh .+2
 1057 0306 00C0      		rjmp .L52
 1058               	.L65:
 384:quantum/quantum.c ****       }
 1059               		.loc 1 384 0 is_stmt 1
 1060 0308 86E0      		ldi r24,lo8(6)
 1061 030a 00C0      		rjmp .L206
 1062               	.L221:
 278:quantum/quantum.c ****     case RESET:
 1063               		.loc 1 278 0
 1064 030c C63C      		cpi r28,-58
 1065 030e 9CE5      		ldi r25,92
 1066 0310 D907      		cpc r29,r25
 1067 0312 00F4      		brsh .L125
 1068 0314 C33C      		cpi r28,-61
 1069 0316 ECE5      		ldi r30,92
 1070 0318 DE07      		cpc r29,r30
 1071 031a 01F4      		brne .L222
 366:quantum/quantum.c ****       rgblight_mode(1);
 1072               		.loc 1 366 0
 1073 031c F801      		movw r30,r16
 1074 031e 8281      		ldd r24,Z+2
 1075 0320 8823      		tst r24
 1076 0322 01F4      		brne .+2
 1077 0324 00C0      		rjmp .L153
 367:quantum/quantum.c ****     }
 1078               		.loc 1 367 0
 1079 0326 81E0      		ldi r24,lo8(1)
 1080 0328 00C0      		rjmp .L206
 1081               	.L222:
 278:quantum/quantum.c ****     case RESET:
 1082               		.loc 1 278 0
 1083 032a C43C      		cpi r28,-60
 1084 032c DC45      		sbci r29,92
 1085 032e 01F0      		breq .+2
 1086 0330 00C0      		rjmp .L119
 371:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1087               		.loc 1 371 0
 1088 0332 F801      		movw r30,r16
 1089 0334 8281      		ldd r24,Z+2
 1090 0336 8823      		tst r24
 1091 0338 01F4      		brne .+2
 1092 033a 00C0      		rjmp .L153
 372:quantum/quantum.c ****         rgblight_step();
 1093               		.loc 1 372 0
 1094 033c 0E94 0000 		call rgblight_get_mode
 1095               	.LVL97:
 1096 0340 6230      		cpi r22,2
 1097 0342 7105      		cpc r23,__zero_reg__
 1098 0344 8105      		cpc r24,__zero_reg__
 1099 0346 9105      		cpc r25,__zero_reg__
 1100 0348 00F0      		brlo .L63
 372:quantum/quantum.c ****         rgblight_step();
 1101               		.loc 1 372 0 is_stmt 0 discriminator 1
 1102 034a 0E94 0000 		call rgblight_get_mode
 1103               	.LVL98:
 1104 034e 6530      		cpi r22,5
 1105 0350 7105      		cpc r23,__zero_reg__
 1106 0352 8105      		cpc r24,__zero_reg__
 1107 0354 9105      		cpc r25,__zero_reg__
 1108 0356 00F4      		brsh .+2
 1109 0358 00C0      		rjmp .L52
 1110               	.L63:
 375:quantum/quantum.c ****       }
 1111               		.loc 1 375 0 is_stmt 1
 1112 035a 82E0      		ldi r24,lo8(2)
 1113 035c 00C0      		rjmp .L206
 1114               	.L125:
 1115 035e F801      		movw r30,r16
 1116 0360 8281      		ldd r24,Z+2
 278:quantum/quantum.c ****     case RESET:
 1117               		.loc 1 278 0
 1118 0362 C73C      		cpi r28,-57
 1119 0364 FCE5      		ldi r31,92
 1120 0366 DF07      		cpc r29,r31
 1121 0368 01F4      		brne .L223
 398:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1122               		.loc 1 398 0
 1123 036a 8823      		tst r24
 1124 036c 01F4      		brne .+2
 1125 036e 00C0      		rjmp .L153
 399:quantum/quantum.c ****         rgblight_step();
 1126               		.loc 1 399 0
 1127 0370 0E94 0000 		call rgblight_get_mode
 1128               	.LVL99:
 1129 0374 6F30      		cpi r22,15
 1130 0376 7105      		cpc r23,__zero_reg__
 1131 0378 8105      		cpc r24,__zero_reg__
 1132 037a 9105      		cpc r25,__zero_reg__
 1133 037c 00F0      		brlo .L69
 399:quantum/quantum.c ****         rgblight_step();
 1134               		.loc 1 399 0 is_stmt 0 discriminator 1
 1135 037e 0E94 0000 		call rgblight_get_mode
 1136               	.LVL100:
 1137 0382 6431      		cpi r22,20
 1138 0384 7105      		cpc r23,__zero_reg__
 1139 0386 8105      		cpc r24,__zero_reg__
 1140 0388 9105      		cpc r25,__zero_reg__
 1141 038a 00F4      		brsh .+2
 1142 038c 00C0      		rjmp .L52
 1143               	.L69:
 402:quantum/quantum.c ****       }
 1144               		.loc 1 402 0 is_stmt 1
 1145 038e 8FE0      		ldi r24,lo8(15)
 1146 0390 00C0      		rjmp .L206
 1147               	.L223:
 278:quantum/quantum.c ****     case RESET:
 1148               		.loc 1 278 0
 1149 0392 C83C      		cpi r28,-56
 1150 0394 DC45      		sbci r29,92
 1151 0396 00F4      		brsh .L224
 389:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1152               		.loc 1 389 0
 1153 0398 8823      		tst r24
 1154 039a 01F4      		brne .+2
 1155 039c 00C0      		rjmp .L153
 390:quantum/quantum.c ****         rgblight_step();
 1156               		.loc 1 390 0
 1157 039e 0E94 0000 		call rgblight_get_mode
 1158               	.LVL101:
 1159 03a2 6930      		cpi r22,9
 1160 03a4 7105      		cpc r23,__zero_reg__
 1161 03a6 8105      		cpc r24,__zero_reg__
 1162 03a8 9105      		cpc r25,__zero_reg__
 1163 03aa 00F0      		brlo .L67
 390:quantum/quantum.c ****         rgblight_step();
 1164               		.loc 1 390 0 is_stmt 0 discriminator 1
 1165 03ac 0E94 0000 		call rgblight_get_mode
 1166               	.LVL102:
 1167 03b0 6E30      		cpi r22,14
 1168 03b2 7105      		cpc r23,__zero_reg__
 1169 03b4 8105      		cpc r24,__zero_reg__
 1170 03b6 9105      		cpc r25,__zero_reg__
 1171 03b8 00F4      		brsh .+2
 1172 03ba 00C0      		rjmp .L52
 1173               	.L67:
 393:quantum/quantum.c ****       }
 1174               		.loc 1 393 0 is_stmt 1
 1175 03bc 89E0      		ldi r24,lo8(9)
 1176 03be 00C0      		rjmp .L206
 1177               	.L224:
 407:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1178               		.loc 1 407 0
 1179 03c0 8823      		tst r24
 1180 03c2 01F4      		brne .+2
 1181 03c4 00C0      		rjmp .L153
 408:quantum/quantum.c ****         rgblight_step();
 1182               		.loc 1 408 0
 1183 03c6 0E94 0000 		call rgblight_get_mode
 1184               	.LVL103:
 1185 03ca 6531      		cpi r22,21
 1186 03cc 7105      		cpc r23,__zero_reg__
 1187 03ce 8105      		cpc r24,__zero_reg__
 1188 03d0 9105      		cpc r25,__zero_reg__
 1189 03d2 00F0      		brlo .L71
 408:quantum/quantum.c ****         rgblight_step();
 1190               		.loc 1 408 0 is_stmt 0 discriminator 1
 1191 03d4 0E94 0000 		call rgblight_get_mode
 1192               	.LVL104:
 1193 03d8 6731      		cpi r22,23
 1194 03da 7105      		cpc r23,__zero_reg__
 1195 03dc 8105      		cpc r24,__zero_reg__
 1196 03de 9105      		cpc r25,__zero_reg__
 1197 03e0 00F4      		brsh .+2
 1198 03e2 00C0      		rjmp .L52
 1199               	.L71:
 411:quantum/quantum.c ****       }
 1200               		.loc 1 411 0 is_stmt 1
 1201 03e4 85E1      		ldi r24,lo8(21)
 1202 03e6 00C0      		rjmp .L206
 1203               	.L124:
 278:quantum/quantum.c ****     case RESET:
 1204               		.loc 1 278 0
 1205 03e8 CC3C      		cpi r28,-52
 1206 03ea ECE5      		ldi r30,92
 1207 03ec DE07      		cpc r29,r30
 1208 03ee 01F4      		brne .L225
 556:quantum/quantum.c ****         shift_interrupted[1] = false;
 1209               		.loc 1 556 0
 1210 03f0 F801      		movw r30,r16
 1211 03f2 8281      		ldd r24,Z+2
 1212 03f4 8823      		tst r24
 1213 03f6 01F0      		breq .L107
 1214               	.L112:
 557:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1215               		.loc 1 557 0
 1216 03f8 1092 0000 		sts shift_interrupted+1,__zero_reg__
 558:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1217               		.loc 1 558 0
 1218 03fc 0E94 0000 		call timer_read
 1219               	.LVL105:
 1220 0400 9093 0000 		sts scs_timer+2+1,r25
 1221 0404 8093 0000 		sts scs_timer+2,r24
 559:quantum/quantum.c ****       }
 1222               		.loc 1 559 0
 1223 0408 80E2      		ldi r24,lo8(32)
 1224               	.L208:
 1225 040a 0E94 0000 		call register_mods
 1226               	.LVL106:
 1227 040e 00C0      		rjmp .L153
 1228               	.L107:
 568:quantum/quantum.c ****           register_code(RSPC_KEY);
 1229               		.loc 1 568 0
 1230 0410 8091 0000 		lds r24,shift_interrupted+1
 1231 0414 8111      		cpse r24,__zero_reg__
 1232 0416 00C0      		rjmp .L109
 568:quantum/quantum.c ****           register_code(RSPC_KEY);
 1233               		.loc 1 568 0 is_stmt 0 discriminator 1
 1234 0418 8091 0000 		lds r24,scs_timer+2
 1235 041c 9091 0000 		lds r25,scs_timer+2+1
 1236 0420 0E94 0000 		call timer_elapsed
 1237               	.LVL107:
 1238 0424 883C      		cpi r24,-56
 1239 0426 9105      		cpc r25,__zero_reg__
 1240 0428 00F4      		brsh .L109
 569:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1241               		.loc 1 569 0 is_stmt 1
 1242 042a 87E2      		ldi r24,lo8(39)
 1243 042c 0E94 0000 		call register_code
 1244               	.LVL108:
 570:quantum/quantum.c ****         }
 1245               		.loc 1 570 0
 1246 0430 87E2      		ldi r24,lo8(39)
 1247 0432 0E94 0000 		call unregister_code
 1248               	.LVL109:
 1249               	.L109:
 572:quantum/quantum.c ****       }
 1250               		.loc 1 572 0
 1251 0436 80E2      		ldi r24,lo8(32)
 1252               	.L207:
 1253 0438 0E94 0000 		call unregister_mods
 1254               	.LVL110:
 1255 043c 00C0      		rjmp .L153
 1256               	.L225:
 278:quantum/quantum.c ****     case RESET:
 1257               		.loc 1 278 0
 1258 043e CD3C      		cpi r28,-51
 1259 0440 FCE5      		ldi r31,92
 1260 0442 DF07      		cpc r29,r31
 1261 0444 00F0      		brlo .+2
 1262 0446 00C0      		rjmp .L126
 1263 0448 CA3C      		cpi r28,-54
 1264 044a 8CE5      		ldi r24,92
 1265 044c D807      		cpc r29,r24
 1266 044e 01F4      		brne .L226
 421:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1267               		.loc 1 421 0
 1268 0450 F801      		movw r30,r16
 1269 0452 8281      		ldd r24,Z+2
 1270 0454 8823      		tst r24
 1271 0456 01F4      		brne .+2
 1272 0458 00C0      		rjmp .L153
 422:quantum/quantum.c ****         rgblight_step();
 1273               		.loc 1 422 0
 1274 045a 0E94 0000 		call rgblight_get_mode
 1275               	.LVL111:
 1276 045e 6931      		cpi r22,25
 1277 0460 7105      		cpc r23,__zero_reg__
 1278 0462 8105      		cpc r24,__zero_reg__
 1279 0464 9105      		cpc r25,__zero_reg__
 1280 0466 00F0      		brlo .L74
 422:quantum/quantum.c ****         rgblight_step();
 1281               		.loc 1 422 0 is_stmt 0 discriminator 1
 1282 0468 0E94 0000 		call rgblight_get_mode
 1283               	.LVL112:
 1284 046c 6232      		cpi r22,34
 1285 046e 7105      		cpc r23,__zero_reg__
 1286 0470 8105      		cpc r24,__zero_reg__
 1287 0472 9105      		cpc r25,__zero_reg__
 1288 0474 00F4      		brsh .+2
 1289 0476 00C0      		rjmp .L52
 1290               	.L74:
 425:quantum/quantum.c ****       }
 1291               		.loc 1 425 0 is_stmt 1
 1292 0478 89E1      		ldi r24,lo8(25)
 1293 047a 00C0      		rjmp .L206
 1294               	.L226:
 278:quantum/quantum.c ****     case RESET:
 1295               		.loc 1 278 0
 1296 047c CB3C      		cpi r28,-53
 1297 047e DC45      		sbci r29,92
 1298 0480 01F0      		breq .+2
 1299 0482 00C0      		rjmp .L119
 534:quantum/quantum.c ****         shift_interrupted[0] = false;
 1300               		.loc 1 534 0
 1301 0484 F801      		movw r30,r16
 1302 0486 8281      		ldd r24,Z+2
 1303 0488 8823      		tst r24
 1304 048a 01F0      		breq .L102
 535:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1305               		.loc 1 535 0
 1306 048c 1092 0000 		sts shift_interrupted,__zero_reg__
 536:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1307               		.loc 1 536 0
 1308 0490 0E94 0000 		call timer_read
 1309               	.LVL113:
 1310 0494 9093 0000 		sts scs_timer+1,r25
 1311 0498 8093 0000 		sts scs_timer,r24
 537:quantum/quantum.c ****       }
 1312               		.loc 1 537 0
 1313 049c 82E0      		ldi r24,lo8(2)
 1314 049e 00C0      		rjmp .L208
 1315               	.L102:
 546:quantum/quantum.c ****           register_code(LSPO_KEY);
 1316               		.loc 1 546 0
 1317 04a0 8091 0000 		lds r24,shift_interrupted
 1318 04a4 8111      		cpse r24,__zero_reg__
 1319 04a6 00C0      		rjmp .L104
 546:quantum/quantum.c ****           register_code(LSPO_KEY);
 1320               		.loc 1 546 0 is_stmt 0 discriminator 1
 1321 04a8 8091 0000 		lds r24,scs_timer
 1322 04ac 9091 0000 		lds r25,scs_timer+1
 1323 04b0 0E94 0000 		call timer_elapsed
 1324               	.LVL114:
 1325 04b4 883C      		cpi r24,-56
 1326 04b6 9105      		cpc r25,__zero_reg__
 1327 04b8 00F4      		brsh .L104
 547:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1328               		.loc 1 547 0 is_stmt 1
 1329 04ba 86E2      		ldi r24,lo8(38)
 1330 04bc 0E94 0000 		call register_code
 1331               	.LVL115:
 548:quantum/quantum.c ****         }
 1332               		.loc 1 548 0
 1333 04c0 86E2      		ldi r24,lo8(38)
 1334 04c2 0E94 0000 		call unregister_code
 1335               	.LVL116:
 1336               	.L104:
 550:quantum/quantum.c ****       }
 1337               		.loc 1 550 0
 1338 04c6 82E0      		ldi r24,lo8(2)
 1339 04c8 00C0      		rjmp .L207
 1340               	.L126:
 278:quantum/quantum.c ****     case RESET:
 1341               		.loc 1 278 0
 1342 04ca C03D      		cpi r28,-48
 1343 04cc ECE5      		ldi r30,92
 1344 04ce DE07      		cpc r29,r30
 1345 04d0 01F4      		brne .L227
 432:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1346               		.loc 1 432 0
 1347 04d2 F801      		movw r30,r16
 1348 04d4 8281      		ldd r24,Z+2
 1349 04d6 8823      		tst r24
 1350 04d8 01F0      		breq .L153
 433:quantum/quantum.c ****       }
 1351               		.loc 1 433 0
 1352 04da 80E0      		ldi r24,0
 1353 04dc 00C0      		rjmp .L209
 1354               	.L227:
 278:quantum/quantum.c ****     case RESET:
 1355               		.loc 1 278 0
 1356 04de C13D      		cpi r28,-47
 1357 04e0 FCE5      		ldi r31,92
 1358 04e2 DF07      		cpc r29,r31
 1359 04e4 01F4      		brne .L228
 437:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1360               		.loc 1 437 0
 1361 04e6 F801      		movw r30,r16
 1362 04e8 8281      		ldd r24,Z+2
 1363 04ea 8823      		tst r24
 1364 04ec 01F0      		breq .L153
 438:quantum/quantum.c ****       }
 1365               		.loc 1 438 0
 1366 04ee 82E0      		ldi r24,lo8(2)
 1367               	.L209:
 1368 04f0 0E94 0000 		call set_output
 1369               	.LVL117:
 1370 04f4 00C0      		rjmp .L153
 1371               	.L228:
 278:quantum/quantum.c ****     case RESET:
 1372               		.loc 1 278 0
 1373 04f6 CD3C      		cpi r28,-51
 1374 04f8 DC45      		sbci r29,92
 1375 04fa 01F0      		breq .+2
 1376 04fc 00C0      		rjmp .L119
 578:quantum/quantum.c ****         shift_interrupted[1] = false;
 1377               		.loc 1 578 0
 1378 04fe F801      		movw r30,r16
 1379 0500 8281      		ldd r24,Z+2
 1380 0502 8111      		cpse r24,__zero_reg__
 1381 0504 00C0      		rjmp .L112
 583:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1382               		.loc 1 583 0
 1383 0506 8091 0000 		lds r24,shift_interrupted+1
 1384 050a 8111      		cpse r24,__zero_reg__
 1385 050c 00C0      		rjmp .L109
 583:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1386               		.loc 1 583 0 is_stmt 0 discriminator 1
 1387 050e 8091 0000 		lds r24,scs_timer+2
 1388 0512 9091 0000 		lds r25,scs_timer+2+1
 1389 0516 0E94 0000 		call timer_elapsed
 1390               	.LVL118:
 1391 051a 883C      		cpi r24,-56
 1392 051c 9105      		cpc r25,__zero_reg__
 1393 051e 00F0      		brlo .+2
 1394 0520 00C0      		rjmp .L109
 584:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1395               		.loc 1 584 0 is_stmt 1
 1396 0522 80E2      		ldi r24,lo8(32)
 1397 0524 0E94 0000 		call unregister_mods
 1398               	.LVL119:
 585:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1399               		.loc 1 585 0
 1400 0528 88E2      		ldi r24,lo8(40)
 1401 052a 0E94 0000 		call register_code
 1402               	.LVL120:
 586:quantum/quantum.c ****       }
 1403               		.loc 1 586 0
 1404 052e 88E2      		ldi r24,lo8(40)
 1405 0530 0E94 0000 		call unregister_code
 1406               	.LVL121:
 1407               	.L153:
 1408               		.loc 1 656 0
 1409 0534 80E0      		ldi r24,0
 1410               	/* epilogue start */
 1411 0536 DF91      		pop r29
 1412 0538 CF91      		pop r28
 1413               	.LVL122:
 1414 053a 1F91      		pop r17
 1415 053c 0F91      		pop r16
 1416               	.LVL123:
 1417 053e FF90      		pop r15
 1418 0540 0895      		ret
 1419               		.cfi_endproc
 1420               	.LFE121:
 1422               		.section	.text.send_char,"ax",@progbits
 1423               	.global	send_char
 1425               	send_char:
 1426               	.LFB126:
 657:quantum/quantum.c **** 
 658:quantum/quantum.c **** __attribute__ ((weak))
 659:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 660:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 661:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 662:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 663:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 664:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 665:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 666:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 667:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 668:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 669:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 670:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 671:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 672:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 673:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 674:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 675:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 676:quantum/quantum.c **** };
 677:quantum/quantum.c **** 
 678:quantum/quantum.c **** __attribute__ ((weak))
 679:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 680:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 681:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 684:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 685:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 686:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 687:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 688:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 689:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 690:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 691:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 692:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 693:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 694:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 695:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 696:quantum/quantum.c **** };
 697:quantum/quantum.c **** 
 698:quantum/quantum.c **** void send_string(const char *str) {
 699:quantum/quantum.c ****   send_string_with_delay(str, 0);
 700:quantum/quantum.c **** }
 701:quantum/quantum.c **** 
 702:quantum/quantum.c **** void send_string_P(const char *str) {
 703:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 704:quantum/quantum.c **** }
 705:quantum/quantum.c **** 
 706:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 707:quantum/quantum.c ****     while (1) {
 708:quantum/quantum.c ****         char ascii_code = *str;
 709:quantum/quantum.c ****         if (!ascii_code) break;
 710:quantum/quantum.c ****         if (ascii_code == 1) {
 711:quantum/quantum.c ****           // tap
 712:quantum/quantum.c ****           uint8_t keycode = *(++str);
 713:quantum/quantum.c ****           register_code(keycode);
 714:quantum/quantum.c ****           unregister_code(keycode);
 715:quantum/quantum.c ****         } else if (ascii_code == 2) {
 716:quantum/quantum.c ****           // down
 717:quantum/quantum.c ****           uint8_t keycode = *(++str);
 718:quantum/quantum.c ****           register_code(keycode);
 719:quantum/quantum.c ****         } else if (ascii_code == 3) {
 720:quantum/quantum.c ****           // up
 721:quantum/quantum.c ****           uint8_t keycode = *(++str);
 722:quantum/quantum.c ****           unregister_code(keycode);
 723:quantum/quantum.c ****         } else {
 724:quantum/quantum.c ****           send_char(ascii_code);
 725:quantum/quantum.c ****         }
 726:quantum/quantum.c ****         ++str;
 727:quantum/quantum.c ****         // interval
 728:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 729:quantum/quantum.c ****     }
 730:quantum/quantum.c **** }
 731:quantum/quantum.c **** 
 732:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 733:quantum/quantum.c ****     while (1) {
 734:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 735:quantum/quantum.c ****         if (!ascii_code) break;
 736:quantum/quantum.c ****         if (ascii_code == 1) {
 737:quantum/quantum.c ****           // tap
 738:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 739:quantum/quantum.c ****           register_code(keycode);
 740:quantum/quantum.c ****           unregister_code(keycode);
 741:quantum/quantum.c ****         } else if (ascii_code == 2) {
 742:quantum/quantum.c ****           // down
 743:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 744:quantum/quantum.c ****           register_code(keycode);
 745:quantum/quantum.c ****         } else if (ascii_code == 3) {
 746:quantum/quantum.c ****           // up
 747:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 748:quantum/quantum.c ****           unregister_code(keycode);
 749:quantum/quantum.c ****         } else {
 750:quantum/quantum.c ****           send_char(ascii_code);
 751:quantum/quantum.c ****         }
 752:quantum/quantum.c ****         ++str;
 753:quantum/quantum.c ****         // interval
 754:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 755:quantum/quantum.c ****     }
 756:quantum/quantum.c **** }
 757:quantum/quantum.c **** 
 758:quantum/quantum.c **** void send_char(char ascii_code) {
 1427               		.loc 1 758 0
 1428               		.cfi_startproc
 1429               	.LVL124:
 1430 0000 CF93      		push r28
 1431               	.LCFI13:
 1432               		.cfi_def_cfa_offset 3
 1433               		.cfi_offset 28, -2
 1434               	/* prologue: function */
 1435               	/* frame size = 0 */
 1436               	/* stack size = 1 */
 1437               	.L__stack_usage = 1
 1438               	.LBB43:
 759:quantum/quantum.c ****   uint8_t keycode;
 760:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1439               		.loc 1 760 0
 1440 0002 282F      		mov r18,r24
 1441 0004 30E0      		ldi r19,0
 1442               	.LVL125:
 1443 0006 F901      		movw r30,r18
 1444 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1445 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1446               	.LVL126:
 1447               	/* #APP */
 1448               	 ;  760 "quantum/quantum.c" 1
 1449 000c C491      		lpm r28, Z
 1450               		
 1451               	 ;  0 "" 2
 1452               	.LVL127:
 1453               	/* #NOAPP */
 1454               	.LBE43:
 1455               	.LBB44:
 761:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1456               		.loc 1 761 0
 1457 000e F901      		movw r30,r18
 1458               	.LVL128:
 1459 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1460 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1461               	.LVL129:
 1462               	/* #APP */
 1463               	 ;  761 "quantum/quantum.c" 1
 1464 0014 2491      		lpm r18, Z
 1465               		
 1466               	 ;  0 "" 2
 1467               	.LVL130:
 1468               	/* #NOAPP */
 1469               	.LBE44:
 1470 0016 2223      		tst r18
 1471 0018 01F0      		breq .L230
 762:quantum/quantum.c ****       register_code(KC_LSFT);
 1472               		.loc 1 762 0
 1473 001a 81EE      		ldi r24,lo8(-31)
 1474               	.LVL131:
 1475 001c 0E94 0000 		call register_code
 1476               	.LVL132:
 763:quantum/quantum.c ****       register_code(keycode);
 1477               		.loc 1 763 0
 1478 0020 8C2F      		mov r24,r28
 1479 0022 0E94 0000 		call register_code
 1480               	.LVL133:
 764:quantum/quantum.c ****       unregister_code(keycode);
 1481               		.loc 1 764 0
 1482 0026 8C2F      		mov r24,r28
 1483 0028 0E94 0000 		call unregister_code
 1484               	.LVL134:
 765:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1485               		.loc 1 765 0
 1486 002c 81EE      		ldi r24,lo8(-31)
 1487 002e 00C0      		rjmp .L231
 1488               	.LVL135:
 1489               	.L230:
 766:quantum/quantum.c ****   } else {
 767:quantum/quantum.c ****       register_code(keycode);
 1490               		.loc 1 767 0
 1491 0030 8C2F      		mov r24,r28
 1492               	.LVL136:
 1493 0032 0E94 0000 		call register_code
 1494               	.LVL137:
 768:quantum/quantum.c ****       unregister_code(keycode);
 1495               		.loc 1 768 0
 1496 0036 8C2F      		mov r24,r28
 1497               	.L231:
 1498               	/* epilogue start */
 769:quantum/quantum.c ****   }
 770:quantum/quantum.c **** }
 1499               		.loc 1 770 0
 1500 0038 CF91      		pop r28
 1501               	.LVL138:
 768:quantum/quantum.c ****       unregister_code(keycode);
 1502               		.loc 1 768 0
 1503 003a 0C94 0000 		jmp unregister_code
 1504               	.LVL139:
 1505               		.cfi_endproc
 1506               	.LFE126:
 1508               		.section	.text.send_string_with_delay,"ax",@progbits
 1509               	.global	send_string_with_delay
 1511               	send_string_with_delay:
 1512               	.LFB124:
 706:quantum/quantum.c ****     while (1) {
 1513               		.loc 1 706 0
 1514               		.cfi_startproc
 1515               	.LVL140:
 1516 0000 FF92      		push r15
 1517               	.LCFI14:
 1518               		.cfi_def_cfa_offset 3
 1519               		.cfi_offset 15, -2
 1520 0002 0F93      		push r16
 1521               	.LCFI15:
 1522               		.cfi_def_cfa_offset 4
 1523               		.cfi_offset 16, -3
 1524 0004 1F93      		push r17
 1525               	.LCFI16:
 1526               		.cfi_def_cfa_offset 5
 1527               		.cfi_offset 17, -4
 1528 0006 CF93      		push r28
 1529               	.LCFI17:
 1530               		.cfi_def_cfa_offset 6
 1531               		.cfi_offset 28, -5
 1532 0008 DF93      		push r29
 1533               	.LCFI18:
 1534               		.cfi_def_cfa_offset 7
 1535               		.cfi_offset 29, -6
 1536               	/* prologue: function */
 1537               	/* frame size = 0 */
 1538               	/* stack size = 5 */
 1539               	.L__stack_usage = 5
 1540 000a EC01      		movw r28,r24
 1541 000c F62E      		mov r15,r22
 1542               	.LVL141:
 1543               	.L240:
 1544               	.LBB45:
 708:quantum/quantum.c ****         if (!ascii_code) break;
 1545               		.loc 1 708 0
 1546 000e 8881      		ld r24,Y
 1547               	.LVL142:
 709:quantum/quantum.c ****         if (ascii_code == 1) {
 1548               		.loc 1 709 0
 1549 0010 8823      		tst r24
 1550 0012 01F0      		breq .L232
 1551 0014 8E01      		movw r16,r28
 1552 0016 0F5F      		subi r16,-1
 1553 0018 1F4F      		sbci r17,-1
 710:quantum/quantum.c ****           // tap
 1554               		.loc 1 710 0
 1555 001a 8130      		cpi r24,lo8(1)
 1556 001c 01F4      		brne .L234
 1557               	.LVL143:
 1558               	.LBB46:
 712:quantum/quantum.c ****           register_code(keycode);
 1559               		.loc 1 712 0
 1560 001e C981      		ldd r28,Y+1
 1561               	.LVL144:
 713:quantum/quantum.c ****           unregister_code(keycode);
 1562               		.loc 1 713 0
 1563 0020 8C2F      		mov r24,r28
 1564               	.LVL145:
 1565 0022 0E94 0000 		call register_code
 1566               	.LVL146:
 714:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1567               		.loc 1 714 0
 1568 0026 8C2F      		mov r24,r28
 1569 0028 00C0      		rjmp .L242
 1570               	.LVL147:
 1571               	.L234:
 1572               	.LBE46:
 715:quantum/quantum.c ****           // down
 1573               		.loc 1 715 0
 1574 002a 8230      		cpi r24,lo8(2)
 1575 002c 01F4      		brne .L236
 1576               	.LVL148:
 1577               	.LBB47:
 718:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1578               		.loc 1 718 0
 1579 002e 8981      		ldd r24,Y+1
 1580               	.LVL149:
 1581 0030 0E94 0000 		call register_code
 1582               	.LVL150:
 1583               	.L241:
 717:quantum/quantum.c ****           register_code(keycode);
 1584               		.loc 1 717 0
 1585 0034 E801      		movw r28,r16
 1586               	.LBE47:
 1587 0036 00C0      		rjmp .L235
 1588               	.LVL151:
 1589               	.L236:
 719:quantum/quantum.c ****           // up
 1590               		.loc 1 719 0
 1591 0038 8330      		cpi r24,lo8(3)
 1592 003a 01F4      		brne .L237
 1593               	.LVL152:
 1594               	.LBB48:
 722:quantum/quantum.c ****         } else {
 1595               		.loc 1 722 0
 1596 003c 8981      		ldd r24,Y+1
 1597               	.LVL153:
 1598               	.L242:
 1599 003e 0E94 0000 		call unregister_code
 1600               	.LVL154:
 1601 0042 00C0      		rjmp .L241
 1602               	.LVL155:
 1603               	.L237:
 1604               	.LBE48:
 724:quantum/quantum.c ****         }
 1605               		.loc 1 724 0
 1606 0044 0E94 0000 		call send_char
 1607               	.LVL156:
 1608               	.L235:
 726:quantum/quantum.c ****         // interval
 1609               		.loc 1 726 0
 1610 0048 2196      		adiw r28,1
 1611               	.LVL157:
 1612               	.LBB49:
 728:quantum/quantum.c ****     }
 1613               		.loc 1 728 0
 1614 004a 8F2D      		mov r24,r15
 1615               	.LVL158:
 1616               	.L238:
 728:quantum/quantum.c ****     }
 1617               		.loc 1 728 0 is_stmt 0 discriminator 1
 1618 004c 8823      		tst r24
 1619 004e 01F0      		breq .L240
 1620               	.LVL159:
 1621               	.LBB50:
 1622               	.LBB51:
 1623               		.loc 2 163 0 is_stmt 1
 1624 0050 EFE9      		ldi r30,lo8(3999)
 1625 0052 FFE0      		ldi r31,hi8(3999)
 1626 0054 3197      	1:	sbiw r30,1
 1627 0056 01F4      		brne 1b
 1628 0058 00C0      		rjmp .
 1629 005a 0000      		nop
 1630 005c 8150      		subi r24,lo8(-(-1))
 1631               	.LVL160:
 1632 005e 00C0      		rjmp .L238
 1633               	.LVL161:
 1634               	.L232:
 1635               	/* epilogue start */
 1636               	.LBE51:
 1637               	.LBE50:
 1638               	.LBE49:
 1639               	.LBE45:
 730:quantum/quantum.c **** 
 1640               		.loc 1 730 0
 1641 0060 DF91      		pop r29
 1642 0062 CF91      		pop r28
 1643               	.LVL162:
 1644 0064 1F91      		pop r17
 1645 0066 0F91      		pop r16
 1646 0068 FF90      		pop r15
 1647               	.LVL163:
 1648 006a 0895      		ret
 1649               		.cfi_endproc
 1650               	.LFE124:
 1652               		.section	.text.send_string,"ax",@progbits
 1653               	.global	send_string
 1655               	send_string:
 1656               	.LFB122:
 698:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1657               		.loc 1 698 0
 1658               		.cfi_startproc
 1659               	.LVL164:
 1660               	/* prologue: function */
 1661               	/* frame size = 0 */
 1662               	/* stack size = 0 */
 1663               	.L__stack_usage = 0
 699:quantum/quantum.c **** }
 1664               		.loc 1 699 0
 1665 0000 60E0      		ldi r22,0
 1666 0002 0C94 0000 		jmp send_string_with_delay
 1667               	.LVL165:
 1668               		.cfi_endproc
 1669               	.LFE122:
 1671               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1672               	.global	send_string_with_delay_P
 1674               	send_string_with_delay_P:
 1675               	.LFB125:
 732:quantum/quantum.c ****     while (1) {
 1676               		.loc 1 732 0
 1677               		.cfi_startproc
 1678               	.LVL166:
 1679 0000 0F93      		push r16
 1680               	.LCFI19:
 1681               		.cfi_def_cfa_offset 3
 1682               		.cfi_offset 16, -2
 1683 0002 1F93      		push r17
 1684               	.LCFI20:
 1685               		.cfi_def_cfa_offset 4
 1686               		.cfi_offset 17, -3
 1687 0004 CF93      		push r28
 1688               	.LCFI21:
 1689               		.cfi_def_cfa_offset 5
 1690               		.cfi_offset 28, -4
 1691 0006 DF93      		push r29
 1692               	.LCFI22:
 1693               		.cfi_def_cfa_offset 6
 1694               		.cfi_offset 29, -5
 1695               	/* prologue: function */
 1696               	/* frame size = 0 */
 1697               	/* stack size = 4 */
 1698               	.L__stack_usage = 4
 1699 0008 EC01      		movw r28,r24
 1700 000a 062F      		mov r16,r22
 1701               	.LVL167:
 1702               	.L252:
 1703               	.LBB52:
 1704               	.LBB53:
 734:quantum/quantum.c ****         if (!ascii_code) break;
 1705               		.loc 1 734 0
 1706 000c FE01      		movw r30,r28
 1707               	/* #APP */
 1708               	 ;  734 "quantum/quantum.c" 1
 1709 000e 8491      		lpm r24, Z
 1710               		
 1711               	 ;  0 "" 2
 1712               	.LVL168:
 1713               	/* #NOAPP */
 1714               	.LBE53:
 735:quantum/quantum.c ****         if (ascii_code == 1) {
 1715               		.loc 1 735 0
 1716 0010 8823      		tst r24
 1717 0012 01F0      		breq .L244
 1718 0014 9E01      		movw r18,r28
 1719 0016 2F5F      		subi r18,-1
 1720 0018 3F4F      		sbci r19,-1
 736:quantum/quantum.c ****           // tap
 1721               		.loc 1 736 0
 1722 001a 8130      		cpi r24,lo8(1)
 1723 001c 01F4      		brne .L246
 1724               	.LBB54:
 1725               	.LBB55:
 738:quantum/quantum.c ****           register_code(keycode);
 1726               		.loc 1 738 0
 1727 001e E901      		movw r28,r18
 1728               	.LVL169:
 1729 0020 F901      		movw r30,r18
 1730               	.LVL170:
 1731               	/* #APP */
 1732               	 ;  738 "quantum/quantum.c" 1
 1733 0022 1491      		lpm r17, Z
 1734               		
 1735               	 ;  0 "" 2
 1736               	.LVL171:
 1737               	/* #NOAPP */
 1738               	.LBE55:
 739:quantum/quantum.c ****           unregister_code(keycode);
 1739               		.loc 1 739 0
 1740 0024 812F      		mov r24,r17
 1741               	.LVL172:
 1742 0026 0E94 0000 		call register_code
 1743               	.LVL173:
 740:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1744               		.loc 1 740 0
 1745 002a 812F      		mov r24,r17
 1746 002c 00C0      		rjmp .L253
 1747               	.LVL174:
 1748               	.L246:
 1749               	.LBE54:
 741:quantum/quantum.c ****           // down
 1750               		.loc 1 741 0
 1751 002e 8230      		cpi r24,lo8(2)
 1752 0030 01F4      		brne .L248
 1753               	.LBB56:
 1754               	.LBB57:
 743:quantum/quantum.c ****           register_code(keycode);
 1755               		.loc 1 743 0
 1756 0032 E901      		movw r28,r18
 1757               	.LVL175:
 1758 0034 F901      		movw r30,r18
 1759               	.LVL176:
 1760               	/* #APP */
 1761               	 ;  743 "quantum/quantum.c" 1
 1762 0036 8491      		lpm r24, Z
 1763               		
 1764               	 ;  0 "" 2
 1765               	.LVL177:
 1766               	/* #NOAPP */
 1767               	.LBE57:
 744:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1768               		.loc 1 744 0
 1769 0038 0E94 0000 		call register_code
 1770               	.LVL178:
 1771               	.LBE56:
 1772 003c 00C0      		rjmp .L247
 1773               	.LVL179:
 1774               	.L248:
 745:quantum/quantum.c ****           // up
 1775               		.loc 1 745 0
 1776 003e 8330      		cpi r24,lo8(3)
 1777 0040 01F4      		brne .L249
 1778               	.LBB58:
 1779               	.LBB59:
 747:quantum/quantum.c ****           unregister_code(keycode);
 1780               		.loc 1 747 0
 1781 0042 E901      		movw r28,r18
 1782               	.LVL180:
 1783 0044 F901      		movw r30,r18
 1784               	.LVL181:
 1785               	/* #APP */
 1786               	 ;  747 "quantum/quantum.c" 1
 1787 0046 8491      		lpm r24, Z
 1788               		
 1789               	 ;  0 "" 2
 1790               	.LVL182:
 1791               	/* #NOAPP */
 1792               	.L253:
 1793               	.LBE59:
 748:quantum/quantum.c ****         } else {
 1794               		.loc 1 748 0
 1795 0048 0E94 0000 		call unregister_code
 1796               	.LVL183:
 1797               	.LBE58:
 1798 004c 00C0      		rjmp .L247
 1799               	.LVL184:
 1800               	.L249:
 750:quantum/quantum.c ****         }
 1801               		.loc 1 750 0
 1802 004e 0E94 0000 		call send_char
 1803               	.LVL185:
 1804               	.L247:
 752:quantum/quantum.c ****         // interval
 1805               		.loc 1 752 0
 1806 0052 2196      		adiw r28,1
 1807               	.LVL186:
 1808               	.LBB60:
 754:quantum/quantum.c ****     }
 1809               		.loc 1 754 0
 1810 0054 802F      		mov r24,r16
 1811               	.LVL187:
 1812               	.L250:
 754:quantum/quantum.c ****     }
 1813               		.loc 1 754 0 is_stmt 0 discriminator 1
 1814 0056 8823      		tst r24
 1815 0058 01F0      		breq .L252
 1816               	.LVL188:
 1817               	.LBB61:
 1818               	.LBB62:
 1819               		.loc 2 163 0 is_stmt 1
 1820 005a EFE9      		ldi r30,lo8(3999)
 1821 005c FFE0      		ldi r31,hi8(3999)
 1822 005e 3197      	1:	sbiw r30,1
 1823 0060 01F4      		brne 1b
 1824 0062 00C0      		rjmp .
 1825 0064 0000      		nop
 1826 0066 8150      		subi r24,lo8(-(-1))
 1827               	.LVL189:
 1828 0068 00C0      		rjmp .L250
 1829               	.LVL190:
 1830               	.L244:
 1831               	/* epilogue start */
 1832               	.LBE62:
 1833               	.LBE61:
 1834               	.LBE60:
 1835               	.LBE52:
 756:quantum/quantum.c **** 
 1836               		.loc 1 756 0
 1837 006a DF91      		pop r29
 1838 006c CF91      		pop r28
 1839               	.LVL191:
 1840 006e 1F91      		pop r17
 1841 0070 0F91      		pop r16
 1842               	.LVL192:
 1843 0072 0895      		ret
 1844               		.cfi_endproc
 1845               	.LFE125:
 1847               		.section	.text.send_string_P,"ax",@progbits
 1848               	.global	send_string_P
 1850               	send_string_P:
 1851               	.LFB123:
 702:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1852               		.loc 1 702 0
 1853               		.cfi_startproc
 1854               	.LVL193:
 1855               	/* prologue: function */
 1856               	/* frame size = 0 */
 1857               	/* stack size = 0 */
 1858               	.L__stack_usage = 0
 703:quantum/quantum.c **** }
 1859               		.loc 1 703 0
 1860 0000 60E0      		ldi r22,0
 1861 0002 0C94 0000 		jmp send_string_with_delay_P
 1862               	.LVL194:
 1863               		.cfi_endproc
 1864               	.LFE123:
 1866               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1867               	.global	set_single_persistent_default_layer
 1869               	set_single_persistent_default_layer:
 1870               	.LFB127:
 771:quantum/quantum.c **** 
 772:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1871               		.loc 1 772 0
 1872               		.cfi_startproc
 1873               	.LVL195:
 1874 0000 CF93      		push r28
 1875               	.LCFI23:
 1876               		.cfi_def_cfa_offset 3
 1877               		.cfi_offset 28, -2
 1878 0002 DF93      		push r29
 1879               	.LCFI24:
 1880               		.cfi_def_cfa_offset 4
 1881               		.cfi_offset 29, -3
 1882               	/* prologue: function */
 1883               	/* frame size = 0 */
 1884               	/* stack size = 2 */
 1885               	.L__stack_usage = 2
 773:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 774:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 775:quantum/quantum.c ****   #endif
 776:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1886               		.loc 1 776 0
 1887 0004 61E0      		ldi r22,lo8(1)
 1888 0006 70E0      		ldi r23,0
 1889 0008 EB01      		movw r28,r22
 1890 000a 00C0      		rjmp 2f
 1891               		1:
 1892 000c CC0F      		lsl r28
 1893 000e DD1F      		rol r29
 1894               		2:
 1895 0010 8A95      		dec r24
 1896 0012 02F4      		brpl 1b
 1897 0014 8C2F      		mov r24,r28
 1898               	.LVL196:
 1899 0016 0E94 0000 		call eeconfig_update_default_layer
 1900               	.LVL197:
 777:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1901               		.loc 1 777 0
 1902 001a BE01      		movw r22,r28
 1903 001c 80E0      		ldi r24,0
 1904 001e 90E0      		ldi r25,0
 1905               	/* epilogue start */
 778:quantum/quantum.c **** }
 1906               		.loc 1 778 0
 1907 0020 DF91      		pop r29
 1908 0022 CF91      		pop r28
 777:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1909               		.loc 1 777 0
 1910 0024 0C94 0000 		jmp default_layer_set
 1911               	.LVL198:
 1912               		.cfi_endproc
 1913               	.LFE127:
 1915               		.section	.text.update_tri_layer,"ax",@progbits
 1916               	.global	update_tri_layer
 1918               	update_tri_layer:
 1919               	.LFB128:
 779:quantum/quantum.c **** 
 780:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1920               		.loc 1 780 0
 1921               		.cfi_startproc
 1922               	.LVL199:
 1923 0000 CF92      		push r12
 1924               	.LCFI25:
 1925               		.cfi_def_cfa_offset 3
 1926               		.cfi_offset 12, -2
 1927 0002 DF92      		push r13
 1928               	.LCFI26:
 1929               		.cfi_def_cfa_offset 4
 1930               		.cfi_offset 13, -3
 1931 0004 EF92      		push r14
 1932               	.LCFI27:
 1933               		.cfi_def_cfa_offset 5
 1934               		.cfi_offset 14, -4
 1935 0006 FF92      		push r15
 1936               	.LCFI28:
 1937               		.cfi_def_cfa_offset 6
 1938               		.cfi_offset 15, -5
 1939 0008 0F93      		push r16
 1940               	.LCFI29:
 1941               		.cfi_def_cfa_offset 7
 1942               		.cfi_offset 16, -6
 1943 000a 1F93      		push r17
 1944               	.LCFI30:
 1945               		.cfi_def_cfa_offset 8
 1946               		.cfi_offset 17, -7
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 1949               	/* stack size = 6 */
 1950               	.L__stack_usage = 6
 1951 000c 01E0      		ldi r16,lo8(1)
 1952 000e 10E0      		ldi r17,0
 1953 0010 20E0      		ldi r18,0
 1954 0012 30E0      		ldi r19,0
 1955 0014 6801      		movw r12,r16
 1956 0016 7901      		movw r14,r18
 1957 0018 00C0      		rjmp 2f
 1958               		1:
 1959 001a CC0C      		lsl r12
 1960 001c DD1C      		rol r13
 1961 001e EE1C      		rol r14
 1962 0020 FF1C      		rol r15
 1963               		2:
 1964 0022 8A95      		dec r24
 1965 0024 02F4      		brpl 1b
 1966 0026 00C0      		rjmp 2f
 1967               		1:
 1968 0028 000F      		lsl r16
 1969 002a 111F      		rol r17
 1970 002c 221F      		rol r18
 1971 002e 331F      		rol r19
 1972               		2:
 1973 0030 6A95      		dec r22
 1974 0032 02F4      		brpl 1b
 1975 0034 0C29      		or r16,r12
 1976 0036 1D29      		or r17,r13
 1977 0038 2E29      		or r18,r14
 1978 003a 3F29      		or r19,r15
 1979 003c C090 0000 		lds r12,layer_state
 1980 0040 D090 0000 		lds r13,layer_state+1
 1981 0044 E090 0000 		lds r14,layer_state+2
 1982 0048 F090 0000 		lds r15,layer_state+3
 1983 004c C022      		and r12,r16
 1984 004e D122      		and r13,r17
 1985 0050 E222      		and r14,r18
 1986 0052 F322      		and r15,r19
 781:quantum/quantum.c ****   if (IS_LAYER_ON(layer1) && IS_LAYER_ON(layer2)) {
 782:quantum/quantum.c ****     layer_on(layer3);
 1987               		.loc 1 782 0
 1988 0054 842F      		mov r24,r20
 1989               	.LVL200:
 781:quantum/quantum.c ****   if (IS_LAYER_ON(layer1) && IS_LAYER_ON(layer2)) {
 1990               		.loc 1 781 0
 1991 0056 C016      		cp r12,r16
 1992 0058 D106      		cpc r13,r17
 1993 005a E206      		cpc r14,r18
 1994 005c F306      		cpc r15,r19
 1995 005e 01F4      		brne .L257
 1996               	/* epilogue start */
 783:quantum/quantum.c ****   } else {
 784:quantum/quantum.c ****     layer_off(layer3);
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1997               		.loc 1 786 0
 1998 0060 1F91      		pop r17
 1999 0062 0F91      		pop r16
 2000 0064 FF90      		pop r15
 2001 0066 EF90      		pop r14
 2002 0068 DF90      		pop r13
 2003 006a CF90      		pop r12
 782:quantum/quantum.c ****   } else {
 2004               		.loc 1 782 0
 2005 006c 0C94 0000 		jmp layer_on
 2006               	.LVL201:
 2007               	.L257:
 2008               	/* epilogue start */
 2009               		.loc 1 786 0
 2010 0070 1F91      		pop r17
 2011 0072 0F91      		pop r16
 2012 0074 FF90      		pop r15
 2013 0076 EF90      		pop r14
 2014 0078 DF90      		pop r13
 2015 007a CF90      		pop r12
 784:quantum/quantum.c ****   }
 2016               		.loc 1 784 0
 2017 007c 0C94 0000 		jmp layer_off
 2018               	.LVL202:
 2019               		.cfi_endproc
 2020               	.LFE128:
 2022               		.section	.text.tap_random_base64,"ax",@progbits
 2023               	.global	tap_random_base64
 2025               	tap_random_base64:
 2026               	.LFB129:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void tap_random_base64(void) {
 2027               		.loc 1 788 0
 2028               		.cfi_startproc
 2029 0000 CF93      		push r28
 2030               	.LCFI31:
 2031               		.cfi_def_cfa_offset 3
 2032               		.cfi_offset 28, -2
 2033 0002 DF93      		push r29
 2034               	.LCFI32:
 2035               		.cfi_def_cfa_offset 4
 2036               		.cfi_offset 29, -3
 2037               	/* prologue: function */
 2038               	/* frame size = 0 */
 2039               	/* stack size = 2 */
 2040               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 790:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 2041               		.loc 1 790 0
 2042 0004 26B5      		in r18,0x26
 2043 0006 C091 8400 		lds r28,132
 2044 000a D091 8500 		lds r29,132+1
 2045 000e 4091 9400 		lds r20,148
 2046 0012 5091 9500 		lds r21,148+1
 2047 0016 8091 BE00 		lds r24,190
 2048 001a 9091 BF00 		lds r25,190+1
 2049 001e C40F      		add r28,r20
 2050 0020 C20F      		add r28,r18
 2051 0022 8C0F      		add r24,r28
 2052 0024 C82F      		mov r28,r24
 2053 0026 CF73      		andi r28,lo8(63)
 2054               	.LVL203:
 791:quantum/quantum.c ****   #else
 792:quantum/quantum.c ****     uint8_t key = rand() % 64;
 793:quantum/quantum.c ****   #endif
 794:quantum/quantum.c ****   switch (key) {
 2055               		.loc 1 794 0
 2056 0028 CE33      		cpi r28,lo8(62)
 2057 002a 00F4      		brsh .L260
 2058 002c C533      		cpi r28,lo8(53)
 2059 002e 00F4      		brsh .L261
 2060 0030 CA31      		cpi r28,lo8(26)
 2061 0032 00F0      		brlo .L259
 2062 0034 C433      		cpi r28,lo8(52)
 2063 0036 00F4      		brsh .L266
 795:quantum/quantum.c ****     case 0 ... 25:
 796:quantum/quantum.c ****       register_code(KC_LSFT);
 797:quantum/quantum.c ****       register_code(key + KC_A);
 798:quantum/quantum.c ****       unregister_code(key + KC_A);
 799:quantum/quantum.c ****       unregister_code(KC_LSFT);
 800:quantum/quantum.c ****       break;
 801:quantum/quantum.c ****     case 26 ... 51:
 802:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 2064               		.loc 1 802 0
 2065 0038 C651      		subi r28,lo8(-(-22))
 2066               	.LVL204:
 2067 003a 00C0      		rjmp .L269
 2068               	.LVL205:
 2069               	.L260:
 794:quantum/quantum.c ****     case 0 ... 25:
 2070               		.loc 1 794 0
 2071 003c CE33      		cpi r28,lo8(62)
 2072 003e 01F0      		breq .L264
 2073 0040 CF33      		cpi r28,lo8(63)
 2074 0042 01F0      		breq .L265
 2075               	.L259:
 796:quantum/quantum.c ****       register_code(key + KC_A);
 2076               		.loc 1 796 0
 2077 0044 81EE      		ldi r24,lo8(-31)
 2078 0046 0E94 0000 		call register_code
 2079               	.LVL206:
 797:quantum/quantum.c ****       unregister_code(key + KC_A);
 2080               		.loc 1 797 0
 2081 004a CC5F      		subi r28,lo8(-(4))
 2082               	.LVL207:
 2083 004c 8C2F      		mov r24,r28
 2084 004e 0E94 0000 		call register_code
 2085               	.LVL208:
 798:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2086               		.loc 1 798 0
 2087 0052 8C2F      		mov r24,r28
 2088 0054 00C0      		rjmp .L268
 2089               	.LVL209:
 2090               	.L266:
 803:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 804:quantum/quantum.c ****       break;
 805:quantum/quantum.c ****     case 52:
 806:quantum/quantum.c ****       register_code(KC_0);
 2091               		.loc 1 806 0
 2092 0056 87E2      		ldi r24,lo8(39)
 2093 0058 0E94 0000 		call register_code
 2094               	.LVL210:
 807:quantum/quantum.c ****       unregister_code(KC_0);
 2095               		.loc 1 807 0
 2096 005c 87E2      		ldi r24,lo8(39)
 2097 005e 00C0      		rjmp .L267
 2098               	.L261:
 808:quantum/quantum.c ****       break;
 809:quantum/quantum.c ****     case 53 ... 61:
 810:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 2099               		.loc 1 810 0
 2100 0060 C751      		subi r28,lo8(-(-23))
 2101               	.LVL211:
 2102               	.L269:
 2103 0062 8C2F      		mov r24,r28
 2104               	.LVL212:
 2105 0064 0E94 0000 		call register_code
 2106               	.LVL213:
 811:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 2107               		.loc 1 811 0
 2108 0068 8C2F      		mov r24,r28
 2109 006a 00C0      		rjmp .L267
 2110               	.LVL214:
 2111               	.L264:
 812:quantum/quantum.c ****       break;
 813:quantum/quantum.c ****     case 62:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 2112               		.loc 1 814 0
 2113 006c 81EE      		ldi r24,lo8(-31)
 2114 006e 0E94 0000 		call register_code
 2115               	.LVL215:
 815:quantum/quantum.c ****       register_code(KC_EQL);
 2116               		.loc 1 815 0
 2117 0072 8EE2      		ldi r24,lo8(46)
 2118 0074 0E94 0000 		call register_code
 2119               	.LVL216:
 816:quantum/quantum.c ****       unregister_code(KC_EQL);
 2120               		.loc 1 816 0
 2121 0078 8EE2      		ldi r24,lo8(46)
 2122               	.LVL217:
 2123               	.L268:
 2124 007a 0E94 0000 		call unregister_code
 2125               	.LVL218:
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2126               		.loc 1 817 0
 2127 007e 81EE      		ldi r24,lo8(-31)
 2128 0080 00C0      		rjmp .L267
 2129               	.LVL219:
 2130               	.L265:
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 63:
 820:quantum/quantum.c ****       register_code(KC_SLSH);
 2131               		.loc 1 820 0
 2132 0082 88E3      		ldi r24,lo8(56)
 2133 0084 0E94 0000 		call register_code
 2134               	.LVL220:
 821:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2135               		.loc 1 821 0
 2136 0088 88E3      		ldi r24,lo8(56)
 2137               	.LVL221:
 2138               	.L267:
 2139               	/* epilogue start */
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****   }
 824:quantum/quantum.c **** }
 2140               		.loc 1 824 0
 2141 008a DF91      		pop r29
 2142 008c CF91      		pop r28
 821:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2143               		.loc 1 821 0
 2144 008e 0C94 0000 		jmp unregister_code
 2145               	.LVL222:
 2146               		.cfi_endproc
 2147               	.LFE129:
 2149               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2150               	.global	matrix_scan_quantum
 2152               	matrix_scan_quantum:
 2153               	.LFB131:
 825:quantum/quantum.c **** 
 826:quantum/quantum.c **** void matrix_init_quantum() {
 827:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 828:quantum/quantum.c ****     backlight_init_ports();
 829:quantum/quantum.c ****   #endif
 830:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 831:quantum/quantum.c ****     audio_init();
 832:quantum/quantum.c ****   #endif
 833:quantum/quantum.c ****   matrix_init_kb();
 834:quantum/quantum.c **** }
 835:quantum/quantum.c **** 
 836:quantum/quantum.c **** void matrix_scan_quantum() {
 2154               		.loc 1 836 0
 2155               		.cfi_startproc
 2156               	/* prologue: function */
 2157               	/* frame size = 0 */
 2158               	/* stack size = 0 */
 2159               	.L__stack_usage = 0
 837:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 838:quantum/quantum.c ****     matrix_scan_music();
 839:quantum/quantum.c ****   #endif
 840:quantum/quantum.c **** 
 841:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 842:quantum/quantum.c ****     matrix_scan_tap_dance();
 843:quantum/quantum.c ****   #endif
 844:quantum/quantum.c **** 
 845:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 846:quantum/quantum.c ****     matrix_scan_combo();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c **** 
 849:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 850:quantum/quantum.c ****     backlight_task();
 851:quantum/quantum.c ****   #endif
 852:quantum/quantum.c **** 
 853:quantum/quantum.c ****   matrix_scan_kb();
 2160               		.loc 1 853 0
 2161 0000 0C94 0000 		jmp matrix_scan_kb
 2162               	.LVL223:
 2163               		.cfi_endproc
 2164               	.LFE131:
 2166               		.section	.text.backlight_set,"ax",@progbits
 2167               		.weak	backlight_set
 2169               	backlight_set:
 2170               	.LFB134:
 854:quantum/quantum.c **** }
 855:quantum/quantum.c **** 
 856:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 857:quantum/quantum.c **** 
 858:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 859:quantum/quantum.c **** 
 860:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 861:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 862:quantum/quantum.c **** #  define COM1x1 COM1C1
 863:quantum/quantum.c **** #  define OCR1x  OCR1C
 864:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 865:quantum/quantum.c **** #  define COM1x1 COM1B1
 866:quantum/quantum.c **** #  define OCR1x  OCR1B
 867:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 868:quantum/quantum.c **** #  define COM1x1 COM1A1
 869:quantum/quantum.c **** #  define OCR1x  OCR1A
 870:quantum/quantum.c **** #else
 871:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 872:quantum/quantum.c **** #endif
 873:quantum/quantum.c **** 
 874:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 875:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 876:quantum/quantum.c **** #endif
 877:quantum/quantum.c **** 
 878:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 879:quantum/quantum.c **** 
 880:quantum/quantum.c **** __attribute__ ((weak))
 881:quantum/quantum.c **** void backlight_init_ports(void)
 882:quantum/quantum.c **** {
 883:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 884:quantum/quantum.c ****   // DDRx |= n
 885:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 886:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 887:quantum/quantum.c ****     // PORTx &= ~n
 888:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 889:quantum/quantum.c ****   #else
 890:quantum/quantum.c ****     // PORTx |= n
 891:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 892:quantum/quantum.c ****   #endif
 893:quantum/quantum.c **** }
 894:quantum/quantum.c **** 
 895:quantum/quantum.c **** __attribute__ ((weak))
 896:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 897:quantum/quantum.c **** 
 898:quantum/quantum.c **** uint8_t backlight_tick = 0;
 899:quantum/quantum.c **** 
 900:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 901:quantum/quantum.c **** void backlight_task(void) {
 902:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 903:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 904:quantum/quantum.c ****       // PORTx &= ~n
 905:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 906:quantum/quantum.c ****     #else
 907:quantum/quantum.c ****       // PORTx |= n
 908:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 909:quantum/quantum.c ****     #endif
 910:quantum/quantum.c ****   } else {
 911:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 912:quantum/quantum.c ****       // PORTx |= n
 913:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 914:quantum/quantum.c ****     #else
 915:quantum/quantum.c ****       // PORTx &= ~n
 916:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 917:quantum/quantum.c ****     #endif
 918:quantum/quantum.c ****   }
 919:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 920:quantum/quantum.c **** }
 921:quantum/quantum.c **** #endif
 922:quantum/quantum.c **** 
 923:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 924:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 925:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** #endif
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** #else // pwm through timer
 930:quantum/quantum.c **** 
 931:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 932:quantum/quantum.c **** 
 933:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 934:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 935:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 936:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 937:quantum/quantum.c ****   else {
 938:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 939:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 940:quantum/quantum.c ****     // and revert what we've done again after squaring.
 941:quantum/quantum.c ****     y = y * y * y >> 8;
 942:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 943:quantum/quantum.c ****       return 0xFFFFU;
 944:quantum/quantum.c ****     else
 945:quantum/quantum.c ****       return (uint16_t) y;
 946:quantum/quantum.c ****   }
 947:quantum/quantum.c **** }
 948:quantum/quantum.c **** 
 949:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 950:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 951:quantum/quantum.c ****   OCR1x = val;
 952:quantum/quantum.c **** }
 953:quantum/quantum.c **** 
 954:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 955:quantum/quantum.c **** __attribute__ ((weak))
 956:quantum/quantum.c **** void backlight_set(uint8_t level) {
 2171               		.loc 1 956 0
 2172               		.cfi_startproc
 2173               	.LVL224:
 2174 0000 CF92      		push r12
 2175               	.LCFI33:
 2176               		.cfi_def_cfa_offset 3
 2177               		.cfi_offset 12, -2
 2178 0002 DF92      		push r13
 2179               	.LCFI34:
 2180               		.cfi_def_cfa_offset 4
 2181               		.cfi_offset 13, -3
 2182 0004 EF92      		push r14
 2183               	.LCFI35:
 2184               		.cfi_def_cfa_offset 5
 2185               		.cfi_offset 14, -4
 2186 0006 FF92      		push r15
 2187               	.LCFI36:
 2188               		.cfi_def_cfa_offset 6
 2189               		.cfi_offset 15, -5
 2190               	/* prologue: function */
 2191               	/* frame size = 0 */
 2192               	/* stack size = 4 */
 2193               	.L__stack_usage = 4
 957:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 2194               		.loc 1 957 0
 2195 0008 8630      		cpi r24,lo8(6)
 2196 000a 00F4      		brsh .L276
 958:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 959:quantum/quantum.c **** 
 960:quantum/quantum.c ****   if (level == 0) {
 2197               		.loc 1 960 0
 2198 000c 8111      		cpse r24,__zero_reg__
 2199 000e 00C0      		rjmp .L272
 961:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 962:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 2200               		.loc 1 962 0
 2201 0010 9091 8000 		lds r25,128
 2202 0014 9F7D      		andi r25,lo8(-33)
 2203 0016 00C0      		rjmp .L278
 2204               	.L276:
 958:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 2205               		.loc 1 958 0
 2206 0018 85E0      		ldi r24,lo8(5)
 2207               	.LVL225:
 2208               	.L272:
 963:quantum/quantum.c ****   } else {
 964:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 965:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
 2209               		.loc 1 965 0
 2210 001a 9091 8000 		lds r25,128
 2211 001e 9062      		ori r25,lo8(32)
 2212               	.L278:
 2213 0020 9093 8000 		sts 128,r25
 966:quantum/quantum.c ****   }
 967:quantum/quantum.c ****   // Set the brightness
 968:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
 2214               		.loc 1 968 0
 2215 0024 282F      		mov r18,r24
 2216 0026 30E0      		ldi r19,0
 2217 0028 AFEF      		ldi r26,lo8(-1)
 2218 002a BFEF      		ldi r27,lo8(-1)
 2219 002c 0E94 0000 		call __umulhisi3
 2220 0030 25E0      		ldi r18,lo8(5)
 2221 0032 30E0      		ldi r19,0
 2222 0034 40E0      		ldi r20,0
 2223 0036 50E0      		ldi r21,0
 2224 0038 0E94 0000 		call __udivmodsi4
 2225               	.LVL226:
 2226               	.LBB68:
 2227               	.LBB69:
 935:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 2228               		.loc 1 935 0
 2229 003c 2C37      		cpi r18,124
 2230 003e 84E1      		ldi r24,20
 2231 0040 3807      		cpc r19,r24
 2232 0042 4105      		cpc r20,__zero_reg__
 2233 0044 5105      		cpc r21,__zero_reg__
 2234               	.LVL227:
 2235 0046 00F4      		brsh .L274
 936:quantum/quantum.c ****   else {
 2236               		.loc 1 936 0
 2237 0048 C901      		movw r24,r18
 2238 004a 69E0      		ldi r22,lo8(9)
 2239 004c 70E0      		ldi r23,0
 2240 004e 0E94 0000 		call __udivmodhi4
 2241 0052 00C0      		rjmp .L275
 2242               	.L274:
 2243               	.LBB70:
 938:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 2244               		.loc 1 938 0
 2245 0054 DA01      		movw r26,r20
 2246 0056 C901      		movw r24,r18
 2247 0058 8A50      		subi r24,10
 2248 005a 974D      		sbci r25,-41
 2249 005c AF4F      		sbci r26,-1
 2250 005e BF4F      		sbci r27,-1
 2251 0060 6627      		clr r22
 2252 0062 782F      		mov r23,r24
 2253 0064 892F      		mov r24,r25
 2254 0066 9A2F      		mov r25,r26
 2255               	.LVL228:
 2256 0068 25EF      		ldi r18,lo8(-11)
 2257 006a 38E2      		ldi r19,lo8(40)
 2258 006c 41E0      		ldi r20,lo8(1)
 2259 006e 50E0      		ldi r21,0
 2260 0070 0E94 0000 		call __udivmodsi4
 2261 0074 6901      		movw r12,r18
 2262 0076 7A01      		movw r14,r20
 2263               	.LVL229:
 941:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 2264               		.loc 1 941 0
 2265 0078 CA01      		movw r24,r20
 2266 007a B901      		movw r22,r18
 2267 007c 0E94 0000 		call __mulsi3
 2268 0080 9B01      		movw r18,r22
 2269 0082 AC01      		movw r20,r24
 2270 0084 C701      		movw r24,r14
 2271 0086 B601      		movw r22,r12
 2272 0088 0E94 0000 		call __mulsi3
 2273 008c BB27      		clr r27
 2274 008e A92F      		mov r26,r25
 2275 0090 982F      		mov r25,r24
 2276 0092 872F      		mov r24,r23
 2277               	.LVL230:
 942:quantum/quantum.c ****       return 0xFFFFU;
 2278               		.loc 1 942 0
 2279 0094 0097      		sbiw r24,0
 2280 0096 21E0      		ldi r18,1
 2281 0098 A207      		cpc r26,r18
 2282 009a B105      		cpc r27,__zero_reg__
 2283 009c 01F0      		breq .L277
 945:quantum/quantum.c ****   }
 2284               		.loc 1 945 0
 2285 009e BC01      		movw r22,r24
 2286 00a0 00C0      		rjmp .L275
 2287               	.L277:
 943:quantum/quantum.c ****     else
 2288               		.loc 1 943 0
 2289 00a2 6FEF      		ldi r22,lo8(-1)
 2290 00a4 7FEF      		ldi r23,lo8(-1)
 2291               	.LVL231:
 2292               	.L275:
 2293               	.LBE70:
 2294               	.LBE69:
 2295               	.LBE68:
 2296               	.LBB71:
 2297               	.LBB72:
 951:quantum/quantum.c **** }
 2298               		.loc 1 951 0
 2299 00a6 7093 8B00 		sts 138+1,r23
 2300 00aa 6093 8A00 		sts 138,r22
 2301               	/* epilogue start */
 2302               	.LBE72:
 2303               	.LBE71:
 969:quantum/quantum.c **** }
 2304               		.loc 1 969 0
 2305 00ae FF90      		pop r15
 2306 00b0 EF90      		pop r14
 2307 00b2 DF90      		pop r13
 2308 00b4 CF90      		pop r12
 2309 00b6 0895      		ret
 2310               		.cfi_endproc
 2311               	.LFE134:
 2313               		.section	.text.backlight_task,"ax",@progbits
 2314               	.global	backlight_task
 2316               	backlight_task:
 2317               	.LFB135:
 970:quantum/quantum.c **** 
 971:quantum/quantum.c **** void backlight_task(void) {}
 2318               		.loc 1 971 0
 2319               		.cfi_startproc
 2320               	/* prologue: function */
 2321               	/* frame size = 0 */
 2322               	/* stack size = 0 */
 2323               	.L__stack_usage = 0
 2324 0000 0895      		ret
 2325               		.cfi_endproc
 2326               	.LFE135:
 2328               		.section	.text.backlight_init_ports,"ax",@progbits
 2329               		.weak	backlight_init_ports
 2331               	backlight_init_ports:
 2332               	.LFB136:
 972:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
 973:quantum/quantum.c **** 
 974:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 975:quantum/quantum.c **** 
 976:quantum/quantum.c **** #define BREATHING_NO_HALT  0
 977:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
 978:quantum/quantum.c **** #define BREATHING_HALT_ON  2
 979:quantum/quantum.c **** #define BREATHING_STEPS 128
 980:quantum/quantum.c **** 
 981:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
 982:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
 983:quantum/quantum.c **** static uint16_t breathing_counter = 0;
 984:quantum/quantum.c **** 
 985:quantum/quantum.c **** bool is_breathing(void) {
 986:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
 987:quantum/quantum.c **** }
 988:quantum/quantum.c **** 
 989:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
 990:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
 991:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
 992:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
 993:quantum/quantum.c **** 
 994:quantum/quantum.c **** void breathing_enable(void)
 995:quantum/quantum.c **** {
 996:quantum/quantum.c ****   breathing_counter = 0;
 997:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
 998:quantum/quantum.c ****   breathing_interrupt_enable();
 999:quantum/quantum.c **** }
1000:quantum/quantum.c **** 
1001:quantum/quantum.c **** void breathing_pulse(void)
1002:quantum/quantum.c **** {
1003:quantum/quantum.c ****     if (get_backlight_level() == 0)
1004:quantum/quantum.c ****       breathing_min();
1005:quantum/quantum.c ****     else
1006:quantum/quantum.c ****       breathing_max();
1007:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1008:quantum/quantum.c ****     breathing_interrupt_enable();
1009:quantum/quantum.c **** }
1010:quantum/quantum.c **** 
1011:quantum/quantum.c **** void breathing_disable(void)
1012:quantum/quantum.c **** {
1013:quantum/quantum.c ****     breathing_interrupt_disable();
1014:quantum/quantum.c ****     // Restore backlight level
1015:quantum/quantum.c ****     backlight_set(get_backlight_level());
1016:quantum/quantum.c **** }
1017:quantum/quantum.c **** 
1018:quantum/quantum.c **** void breathing_self_disable(void)
1019:quantum/quantum.c **** {
1020:quantum/quantum.c ****   if (get_backlight_level() == 0)
1021:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1022:quantum/quantum.c ****   else
1023:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1024:quantum/quantum.c **** }
1025:quantum/quantum.c **** 
1026:quantum/quantum.c **** void breathing_toggle(void) {
1027:quantum/quantum.c ****   if (is_breathing())
1028:quantum/quantum.c ****     breathing_disable();
1029:quantum/quantum.c ****   else
1030:quantum/quantum.c ****     breathing_enable();
1031:quantum/quantum.c **** }
1032:quantum/quantum.c **** 
1033:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1034:quantum/quantum.c **** {
1035:quantum/quantum.c ****   if (!value)
1036:quantum/quantum.c ****     value = 1;
1037:quantum/quantum.c ****   breathing_period = value;
1038:quantum/quantum.c **** }
1039:quantum/quantum.c **** 
1040:quantum/quantum.c **** void breathing_period_default(void) {
1041:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1042:quantum/quantum.c **** }
1043:quantum/quantum.c **** 
1044:quantum/quantum.c **** void breathing_period_inc(void)
1045:quantum/quantum.c **** {
1046:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1047:quantum/quantum.c **** }
1048:quantum/quantum.c **** 
1049:quantum/quantum.c **** void breathing_period_dec(void)
1050:quantum/quantum.c **** {
1051:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1052:quantum/quantum.c **** }
1053:quantum/quantum.c **** 
1054:quantum/quantum.c **** /* To generate breathing curve in python:
1055:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1056:quantum/quantum.c ****  */
1057:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1058:quantum/quantum.c **** 
1059:quantum/quantum.c **** // Use this before the cie_lightness function.
1060:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1061:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1062:quantum/quantum.c **** }
1063:quantum/quantum.c **** 
1064:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1065:quantum/quantum.c ****  * about 244 times per second.
1066:quantum/quantum.c ****  */
1067:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1070:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1071:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1072:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1073:quantum/quantum.c **** 
1074:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1075:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1076:quantum/quantum.c ****   {
1077:quantum/quantum.c ****       breathing_interrupt_disable();
1078:quantum/quantum.c ****   }
1079:quantum/quantum.c **** 
1080:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1084:quantum/quantum.c **** 
1085:quantum/quantum.c **** __attribute__ ((weak))
1086:quantum/quantum.c **** void backlight_init_ports(void)
1087:quantum/quantum.c **** {
 2333               		.loc 1 1087 0
 2334               		.cfi_startproc
 2335               	/* prologue: function */
 2336               	/* frame size = 0 */
 2337               	/* stack size = 0 */
 2338               	.L__stack_usage = 0
1088:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1089:quantum/quantum.c ****   // DDRx |= n
1090:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 2339               		.loc 1 1090 0
 2340 0000 269A      		sbi 0x4,6
1091:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1092:quantum/quantum.c ****     // PORTx &= ~n
1093:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 2341               		.loc 1 1093 0
 2342 0002 2E98      		cbi 0x5,6
1094:quantum/quantum.c ****   #else
1095:quantum/quantum.c ****     // PORTx |= n
1096:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1097:quantum/quantum.c ****   #endif
1098:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1099:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1100:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1101:quantum/quantum.c **** 
1102:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1103:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1104:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1105:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1106:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   /*
1109:quantum/quantum.c ****   14.8.3:
1110:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1111:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1112:quantum/quantum.c ****   */
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
 2343               		.loc 1 1114 0
 2344 0004 82E2      		ldi r24,lo8(34)
 2345 0006 8093 8000 		sts 128,r24
1115:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
 2346               		.loc 1 1115 0
 2347 000a 89E1      		ldi r24,lo8(25)
 2348 000c 8093 8100 		sts 129,r24
1116:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1117:quantum/quantum.c ****   ICR1 = TIMER_TOP;
 2349               		.loc 1 1117 0
 2350 0010 8FEF      		ldi r24,lo8(-1)
 2351 0012 9FEF      		ldi r25,lo8(-1)
 2352 0014 9093 8700 		sts 134+1,r25
 2353 0018 8093 8600 		sts 134,r24
1118:quantum/quantum.c **** 
1119:quantum/quantum.c ****   backlight_init();
 2354               		.loc 1 1119 0
 2355 001c 0C94 0000 		jmp backlight_init
 2356               	.LVL232:
 2357               		.cfi_endproc
 2358               	.LFE136:
 2360               		.section	.text.matrix_init_quantum,"ax",@progbits
 2361               	.global	matrix_init_quantum
 2363               	matrix_init_quantum:
 2364               	.LFB130:
 826:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 2365               		.loc 1 826 0
 2366               		.cfi_startproc
 2367               	/* prologue: function */
 2368               	/* frame size = 0 */
 2369               	/* stack size = 0 */
 2370               	.L__stack_usage = 0
 828:quantum/quantum.c ****   #endif
 2371               		.loc 1 828 0
 2372 0000 0E94 0000 		call backlight_init_ports
 2373               	.LVL233:
 833:quantum/quantum.c **** }
 2374               		.loc 1 833 0
 2375 0004 0C94 0000 		jmp matrix_init_kb
 2376               	.LVL234:
 2377               		.cfi_endproc
 2378               	.LFE130:
 2380               		.section	.text.send_nibble,"ax",@progbits
 2381               	.global	send_nibble
 2383               	send_nibble:
 2384               	.LFB140:
1120:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1121:quantum/quantum.c ****     breathing_enable();
1122:quantum/quantum.c ****   #endif
1123:quantum/quantum.c **** }
1124:quantum/quantum.c **** 
1125:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1126:quantum/quantum.c **** 
1127:quantum/quantum.c **** #else // backlight
1128:quantum/quantum.c **** 
1129:quantum/quantum.c **** __attribute__ ((weak))
1130:quantum/quantum.c **** void backlight_init_ports(void) {}
1131:quantum/quantum.c **** 
1132:quantum/quantum.c **** __attribute__ ((weak))
1133:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1134:quantum/quantum.c **** 
1135:quantum/quantum.c **** #endif // backlight
1136:quantum/quantum.c **** 
1137:quantum/quantum.c **** 
1138:quantum/quantum.c **** // Functions for spitting out values
1139:quantum/quantum.c **** //
1140:quantum/quantum.c **** 
1141:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1142:quantum/quantum.c ****     uint16_t word = (number >> 16);
1143:quantum/quantum.c ****     send_word(word);
1144:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1145:quantum/quantum.c **** }
1146:quantum/quantum.c **** 
1147:quantum/quantum.c **** void send_word(uint16_t number) {
1148:quantum/quantum.c ****     uint8_t byte = number >> 8;
1149:quantum/quantum.c ****     send_byte(byte);
1150:quantum/quantum.c ****     send_byte(number & 0xFF);
1151:quantum/quantum.c **** }
1152:quantum/quantum.c **** 
1153:quantum/quantum.c **** void send_byte(uint8_t number) {
1154:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1155:quantum/quantum.c ****     send_nibble(nibble);
1156:quantum/quantum.c ****     send_nibble(number & 0xF);
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2385               		.loc 1 1159 0
 2386               		.cfi_startproc
 2387               	.LVL235:
 2388 0000 CF93      		push r28
 2389               	.LCFI37:
 2390               		.cfi_def_cfa_offset 3
 2391               		.cfi_offset 28, -2
 2392               	/* prologue: function */
 2393               	/* frame size = 0 */
 2394               	/* stack size = 1 */
 2395               	.L__stack_usage = 1
1160:quantum/quantum.c ****     switch (number) {
 2396               		.loc 1 1160 0
 2397 0002 8A30      		cpi r24,lo8(10)
 2398 0004 00F4      		brsh .L284
 2399 0006 8130      		cpi r24,lo8(1)
 2400 0008 00F4      		brsh .L292
1161:quantum/quantum.c ****         case 0:
1162:quantum/quantum.c ****             register_code(KC_0);
 2401               		.loc 1 1162 0
 2402 000a 87E2      		ldi r24,lo8(39)
 2403               	.LVL236:
 2404 000c 0E94 0000 		call register_code
 2405               	.LVL237:
1163:quantum/quantum.c ****             unregister_code(KC_0);
 2406               		.loc 1 1163 0
 2407 0010 87E2      		ldi r24,lo8(39)
 2408 0012 00C0      		rjmp .L290
 2409               	.LVL238:
 2410               	.L284:
1160:quantum/quantum.c ****     switch (number) {
 2411               		.loc 1 1160 0
 2412 0014 8031      		cpi r24,lo8(16)
 2413 0016 00F4      		brsh .L293
1164:quantum/quantum.c ****             break;
1165:quantum/quantum.c ****         case 1 ... 9:
1166:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1167:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1168:quantum/quantum.c ****             break;
1169:quantum/quantum.c ****         case 0xA ... 0xF:
1170:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2414               		.loc 1 1170 0
 2415 0018 CAEF      		ldi r28,lo8(-6)
 2416 001a 00C0      		rjmp .L291
 2417               	.L292:
1166:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 2418               		.loc 1 1166 0
 2419 001c CDE1      		ldi r28,lo8(29)
 2420               	.L291:
 2421               		.loc 1 1170 0
 2422 001e C80F      		add r28,r24
 2423 0020 8C2F      		mov r24,r28
 2424               	.LVL239:
 2425 0022 0E94 0000 		call register_code
 2426               	.LVL240:
1171:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2427               		.loc 1 1171 0
 2428 0026 8C2F      		mov r24,r28
 2429               	.L290:
 2430               	/* epilogue start */
1172:quantum/quantum.c ****             break;
1173:quantum/quantum.c ****     }
1174:quantum/quantum.c **** }
 2431               		.loc 1 1174 0
 2432 0028 CF91      		pop r28
1171:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2433               		.loc 1 1171 0
 2434 002a 0C94 0000 		jmp unregister_code
 2435               	.LVL241:
 2436               	.L293:
 2437               	/* epilogue start */
 2438               		.loc 1 1174 0
 2439 002e CF91      		pop r28
 2440 0030 0895      		ret
 2441               		.cfi_endproc
 2442               	.LFE140:
 2444               		.section	.text.send_byte,"ax",@progbits
 2445               	.global	send_byte
 2447               	send_byte:
 2448               	.LFB139:
1153:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 2449               		.loc 1 1153 0
 2450               		.cfi_startproc
 2451               	.LVL242:
 2452 0000 CF93      		push r28
 2453               	.LCFI38:
 2454               		.cfi_def_cfa_offset 3
 2455               		.cfi_offset 28, -2
 2456               	/* prologue: function */
 2457               	/* frame size = 0 */
 2458               	/* stack size = 1 */
 2459               	.L__stack_usage = 1
 2460 0002 C82F      		mov r28,r24
 2461               	.LVL243:
1155:quantum/quantum.c ****     send_nibble(number & 0xF);
 2462               		.loc 1 1155 0
 2463 0004 8295      		swap r24
 2464               	.LVL244:
 2465 0006 8F70      		andi r24,lo8(15)
 2466 0008 0E94 0000 		call send_nibble
 2467               	.LVL245:
1156:quantum/quantum.c **** }
 2468               		.loc 1 1156 0
 2469 000c 8C2F      		mov r24,r28
 2470 000e 8F70      		andi r24,lo8(15)
 2471               	/* epilogue start */
1157:quantum/quantum.c **** 
 2472               		.loc 1 1157 0
 2473 0010 CF91      		pop r28
 2474               	.LVL246:
1156:quantum/quantum.c **** }
 2475               		.loc 1 1156 0
 2476 0012 0C94 0000 		jmp send_nibble
 2477               	.LVL247:
 2478               		.cfi_endproc
 2479               	.LFE139:
 2481               		.section	.text.send_word,"ax",@progbits
 2482               	.global	send_word
 2484               	send_word:
 2485               	.LFB138:
1147:quantum/quantum.c ****     uint8_t byte = number >> 8;
 2486               		.loc 1 1147 0
 2487               		.cfi_startproc
 2488               	.LVL248:
 2489 0000 CF93      		push r28
 2490               	.LCFI39:
 2491               		.cfi_def_cfa_offset 3
 2492               		.cfi_offset 28, -2
 2493               	/* prologue: function */
 2494               	/* frame size = 0 */
 2495               	/* stack size = 1 */
 2496               	.L__stack_usage = 1
 2497 0002 C82F      		mov r28,r24
 2498               	.LVL249:
1149:quantum/quantum.c ****     send_byte(number & 0xFF);
 2499               		.loc 1 1149 0
 2500 0004 892F      		mov r24,r25
 2501               	.LVL250:
 2502 0006 0E94 0000 		call send_byte
 2503               	.LVL251:
1150:quantum/quantum.c **** }
 2504               		.loc 1 1150 0
 2505 000a 8C2F      		mov r24,r28
 2506               	/* epilogue start */
1151:quantum/quantum.c **** 
 2507               		.loc 1 1151 0
 2508 000c CF91      		pop r28
1150:quantum/quantum.c **** }
 2509               		.loc 1 1150 0
 2510 000e 0C94 0000 		jmp send_byte
 2511               	.LVL252:
 2512               		.cfi_endproc
 2513               	.LFE138:
 2515               		.section	.text.send_dword,"ax",@progbits
 2516               	.global	send_dword
 2518               	send_dword:
 2519               	.LFB137:
1141:quantum/quantum.c ****     uint16_t word = (number >> 16);
 2520               		.loc 1 1141 0
 2521               		.cfi_startproc
 2522               	.LVL253:
 2523 0000 CF92      		push r12
 2524               	.LCFI40:
 2525               		.cfi_def_cfa_offset 3
 2526               		.cfi_offset 12, -2
 2527 0002 DF92      		push r13
 2528               	.LCFI41:
 2529               		.cfi_def_cfa_offset 4
 2530               		.cfi_offset 13, -3
 2531 0004 EF92      		push r14
 2532               	.LCFI42:
 2533               		.cfi_def_cfa_offset 5
 2534               		.cfi_offset 14, -4
 2535 0006 FF92      		push r15
 2536               	.LCFI43:
 2537               		.cfi_def_cfa_offset 6
 2538               		.cfi_offset 15, -5
 2539               	/* prologue: function */
 2540               	/* frame size = 0 */
 2541               	/* stack size = 4 */
 2542               	.L__stack_usage = 4
 2543 0008 6B01      		movw r12,r22
 2544 000a 7C01      		movw r14,r24
 2545               	.LVL254:
1143:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2546               		.loc 1 1143 0
 2547 000c C701      		movw r24,r14
 2548 000e 0E94 0000 		call send_word
 2549               	.LVL255:
1144:quantum/quantum.c **** }
 2550               		.loc 1 1144 0
 2551 0012 C601      		movw r24,r12
 2552               	/* epilogue start */
1145:quantum/quantum.c **** 
 2553               		.loc 1 1145 0
 2554 0014 FF90      		pop r15
 2555 0016 EF90      		pop r14
 2556 0018 DF90      		pop r13
 2557 001a CF90      		pop r12
 2558               	.LVL256:
1144:quantum/quantum.c **** }
 2559               		.loc 1 1144 0
 2560 001c 0C94 0000 		jmp send_word
 2561               	.LVL257:
 2562               		.cfi_endproc
 2563               	.LFE137:
 2565               		.section	.text.hex_to_keycode,"ax",@progbits
 2566               		.weak	hex_to_keycode
 2568               	hex_to_keycode:
 2569               	.LFB141:
1175:quantum/quantum.c **** 
1176:quantum/quantum.c **** 
1177:quantum/quantum.c **** __attribute__((weak))
1178:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1179:quantum/quantum.c **** {
 2570               		.loc 1 1179 0
 2571               		.cfi_startproc
 2572               	.LVL258:
 2573               	/* prologue: function */
 2574               	/* frame size = 0 */
 2575               	/* stack size = 0 */
 2576               	.L__stack_usage = 0
1180:quantum/quantum.c ****   hex = hex & 0xF;
 2577               		.loc 1 1180 0
 2578 0000 282F      		mov r18,r24
 2579 0002 2F70      		andi r18,lo8(15)
 2580               	.LVL259:
1181:quantum/quantum.c ****   if (hex == 0x0) {
 2581               		.loc 1 1181 0
 2582 0004 01F0      		breq .L300
 2583 0006 822F      		mov r24,r18
 2584 0008 90E0      		ldi r25,0
1182:quantum/quantum.c ****     return KC_0;
1183:quantum/quantum.c ****   } else if (hex < 0xA) {
 2585               		.loc 1 1183 0
 2586 000a 2A30      		cpi r18,lo8(10)
 2587 000c 00F4      		brsh .L299
1184:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2588               		.loc 1 1184 0
 2589 000e 4D96      		adiw r24,29
 2590 0010 0895      		ret
 2591               	.L299:
1185:quantum/quantum.c ****   } else {
1186:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2592               		.loc 1 1186 0
 2593 0012 0697      		sbiw r24,6
 2594 0014 0895      		ret
 2595               	.L300:
1182:quantum/quantum.c ****   } else if (hex < 0xA) {
 2596               		.loc 1 1182 0
 2597 0016 87E2      		ldi r24,lo8(39)
 2598 0018 90E0      		ldi r25,0
1187:quantum/quantum.c ****   }
1188:quantum/quantum.c **** }
 2599               		.loc 1 1188 0
 2600 001a 0895      		ret
 2601               		.cfi_endproc
 2602               	.LFE141:
 2604               		.section	.text.api_send_unicode,"ax",@progbits
 2605               	.global	api_send_unicode
 2607               	api_send_unicode:
 2608               	.LFB142:
1189:quantum/quantum.c **** 
1190:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2609               		.loc 1 1190 0
 2610               		.cfi_startproc
 2611               	.LVL260:
 2612               	/* prologue: function */
 2613               	/* frame size = 0 */
 2614               	/* stack size = 0 */
 2615               	.L__stack_usage = 0
 2616 0000 0895      		ret
 2617               		.cfi_endproc
 2618               	.LFE142:
 2620               		.section	.text.led_set_user,"ax",@progbits
 2621               		.weak	led_set_user
 2623               	led_set_user:
 2624               	.LFB143:
1191:quantum/quantum.c **** #ifdef API_ENABLE
1192:quantum/quantum.c ****     uint8_t chunk[4];
1193:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1194:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1195:quantum/quantum.c **** #endif
1196:quantum/quantum.c **** }
1197:quantum/quantum.c **** 
1198:quantum/quantum.c **** __attribute__ ((weak))
1199:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2625               		.loc 1 1199 0
 2626               		.cfi_startproc
 2627               	.LVL261:
 2628               	/* prologue: function */
 2629               	/* frame size = 0 */
 2630               	/* stack size = 0 */
 2631               	.L__stack_usage = 0
 2632 0000 0895      		ret
 2633               		.cfi_endproc
 2634               	.LFE143:
 2636               		.section	.text.led_set_kb,"ax",@progbits
 2637               		.weak	led_set_kb
 2639               	led_set_kb:
 2640               	.LFB144:
1200:quantum/quantum.c **** 
1201:quantum/quantum.c **** }
1202:quantum/quantum.c **** 
1203:quantum/quantum.c **** __attribute__ ((weak))
1204:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2641               		.loc 1 1204 0
 2642               		.cfi_startproc
 2643               	.LVL262:
 2644               	/* prologue: function */
 2645               	/* frame size = 0 */
 2646               	/* stack size = 0 */
 2647               	.L__stack_usage = 0
1205:quantum/quantum.c ****     led_set_user(usb_led);
 2648               		.loc 1 1205 0
 2649 0000 0C94 0000 		jmp led_set_user
 2650               	.LVL263:
 2651               		.cfi_endproc
 2652               	.LFE144:
 2654               		.section	.text.led_init_ports,"ax",@progbits
 2655               		.weak	led_init_ports
 2657               	led_init_ports:
 2658               	.LFB145:
1206:quantum/quantum.c **** }
1207:quantum/quantum.c **** 
1208:quantum/quantum.c **** __attribute__ ((weak))
1209:quantum/quantum.c **** void led_init_ports(void)
1210:quantum/quantum.c **** {
 2659               		.loc 1 1210 0
 2660               		.cfi_startproc
 2661               	/* prologue: function */
 2662               	/* frame size = 0 */
 2663               	/* stack size = 0 */
 2664               	.L__stack_usage = 0
 2665 0000 0895      		ret
 2666               		.cfi_endproc
 2667               	.LFE145:
 2669               		.section	.text.led_set,"ax",@progbits
 2670               		.weak	led_set
 2672               	led_set:
 2673               	.LFB146:
1211:quantum/quantum.c **** 
1212:quantum/quantum.c **** }
1213:quantum/quantum.c **** 
1214:quantum/quantum.c **** __attribute__ ((weak))
1215:quantum/quantum.c **** void led_set(uint8_t usb_led)
1216:quantum/quantum.c **** {
 2674               		.loc 1 1216 0
 2675               		.cfi_startproc
 2676               	.LVL264:
 2677               	/* prologue: function */
 2678               	/* frame size = 0 */
 2679               	/* stack size = 0 */
 2680               	.L__stack_usage = 0
1217:quantum/quantum.c **** 
1218:quantum/quantum.c ****   // Example LED Code
1219:quantum/quantum.c ****   //
1220:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1221:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1222:quantum/quantum.c ****     // {
1223:quantum/quantum.c ****     //     // Output high.
1224:quantum/quantum.c ****     //     DDRE |= (1<<6);
1225:quantum/quantum.c ****     //     PORTE |= (1<<6);
1226:quantum/quantum.c ****     // }
1227:quantum/quantum.c ****     // else
1228:quantum/quantum.c ****     // {
1229:quantum/quantum.c ****     //     // Output low.
1230:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1231:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1232:quantum/quantum.c ****     // }
1233:quantum/quantum.c **** 
1234:quantum/quantum.c ****   led_set_kb(usb_led);
 2681               		.loc 1 1234 0
 2682 0000 0C94 0000 		jmp led_set_kb
 2683               	.LVL265:
 2684               		.cfi_endproc
 2685               	.LFE146:
 2687               		.section	.text.startup_user,"ax",@progbits
 2688               		.weak	startup_user
 2690               	startup_user:
 2691               	.LFB147:
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** 
1238:quantum/quantum.c **** //------------------------------------------------------------------------------
1239:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1240:quantum/quantum.c **** // different events such as startup and bootloader jump
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void startup_user() {}
 2692               		.loc 1 1243 0
 2693               		.cfi_startproc
 2694               	/* prologue: function */
 2695               	/* frame size = 0 */
 2696               	/* stack size = 0 */
 2697               	.L__stack_usage = 0
 2698 0000 0895      		ret
 2699               		.cfi_endproc
 2700               	.LFE147:
 2702               		.section	.text.shutdown_user,"ax",@progbits
 2703               		.weak	shutdown_user
 2705               	shutdown_user:
 2706               	.LFB148:
1244:quantum/quantum.c **** 
1245:quantum/quantum.c **** __attribute__ ((weak))
1246:quantum/quantum.c **** void shutdown_user() {}
 2707               		.loc 1 1246 0
 2708               		.cfi_startproc
 2709               	/* prologue: function */
 2710               	/* frame size = 0 */
 2711               	/* stack size = 0 */
 2712               	.L__stack_usage = 0
 2713 0000 0895      		ret
 2714               		.cfi_endproc
 2715               	.LFE148:
 2717               		.weak	ascii_to_keycode_lut
 2718               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2721               	ascii_to_keycode_lut:
 2722 0000 00        		.byte	0
 2723 0001 00        		.byte	0
 2724 0002 00        		.byte	0
 2725 0003 00        		.byte	0
 2726 0004 00        		.byte	0
 2727 0005 00        		.byte	0
 2728 0006 00        		.byte	0
 2729 0007 00        		.byte	0
 2730 0008 2A        		.byte	42
 2731 0009 2B        		.byte	43
 2732 000a 28        		.byte	40
 2733 000b 00        		.byte	0
 2734 000c 00        		.byte	0
 2735 000d 00        		.byte	0
 2736 000e 00        		.byte	0
 2737 000f 00        		.byte	0
 2738 0010 00        		.byte	0
 2739 0011 00        		.byte	0
 2740 0012 00        		.byte	0
 2741 0013 00        		.byte	0
 2742 0014 00        		.byte	0
 2743 0015 00        		.byte	0
 2744 0016 00        		.byte	0
 2745 0017 00        		.byte	0
 2746 0018 00        		.byte	0
 2747 0019 00        		.byte	0
 2748 001a 00        		.byte	0
 2749 001b 29        		.byte	41
 2750 001c 00        		.byte	0
 2751 001d 00        		.byte	0
 2752 001e 00        		.byte	0
 2753 001f 00        		.byte	0
 2754 0020 2C        		.byte	44
 2755 0021 1E        		.byte	30
 2756 0022 34        		.byte	52
 2757 0023 20        		.byte	32
 2758 0024 21        		.byte	33
 2759 0025 22        		.byte	34
 2760 0026 24        		.byte	36
 2761 0027 34        		.byte	52
 2762 0028 26        		.byte	38
 2763 0029 27        		.byte	39
 2764 002a 25        		.byte	37
 2765 002b 2E        		.byte	46
 2766 002c 36        		.byte	54
 2767 002d 2D        		.byte	45
 2768 002e 37        		.byte	55
 2769 002f 38        		.byte	56
 2770 0030 27        		.byte	39
 2771 0031 1E        		.byte	30
 2772 0032 1F        		.byte	31
 2773 0033 20        		.byte	32
 2774 0034 21        		.byte	33
 2775 0035 22        		.byte	34
 2776 0036 23        		.byte	35
 2777 0037 24        		.byte	36
 2778 0038 25        		.byte	37
 2779 0039 26        		.byte	38
 2780 003a 33        		.byte	51
 2781 003b 33        		.byte	51
 2782 003c 36        		.byte	54
 2783 003d 2E        		.byte	46
 2784 003e 37        		.byte	55
 2785 003f 38        		.byte	56
 2786 0040 1F        		.byte	31
 2787 0041 04        		.byte	4
 2788 0042 05        		.byte	5
 2789 0043 06        		.byte	6
 2790 0044 07        		.byte	7
 2791 0045 08        		.byte	8
 2792 0046 09        		.byte	9
 2793 0047 0A        		.byte	10
 2794 0048 0B        		.byte	11
 2795 0049 0C        		.byte	12
 2796 004a 0D        		.byte	13
 2797 004b 0E        		.byte	14
 2798 004c 0F        		.byte	15
 2799 004d 10        		.byte	16
 2800 004e 11        		.byte	17
 2801 004f 12        		.byte	18
 2802 0050 13        		.byte	19
 2803 0051 14        		.byte	20
 2804 0052 15        		.byte	21
 2805 0053 16        		.byte	22
 2806 0054 17        		.byte	23
 2807 0055 18        		.byte	24
 2808 0056 19        		.byte	25
 2809 0057 1A        		.byte	26
 2810 0058 1B        		.byte	27
 2811 0059 1C        		.byte	28
 2812 005a 1D        		.byte	29
 2813 005b 2F        		.byte	47
 2814 005c 31        		.byte	49
 2815 005d 30        		.byte	48
 2816 005e 23        		.byte	35
 2817 005f 2D        		.byte	45
 2818 0060 35        		.byte	53
 2819 0061 04        		.byte	4
 2820 0062 05        		.byte	5
 2821 0063 06        		.byte	6
 2822 0064 07        		.byte	7
 2823 0065 08        		.byte	8
 2824 0066 09        		.byte	9
 2825 0067 0A        		.byte	10
 2826 0068 0B        		.byte	11
 2827 0069 0C        		.byte	12
 2828 006a 0D        		.byte	13
 2829 006b 0E        		.byte	14
 2830 006c 0F        		.byte	15
 2831 006d 10        		.byte	16
 2832 006e 11        		.byte	17
 2833 006f 12        		.byte	18
 2834 0070 13        		.byte	19
 2835 0071 14        		.byte	20
 2836 0072 15        		.byte	21
 2837 0073 16        		.byte	22
 2838 0074 17        		.byte	23
 2839 0075 18        		.byte	24
 2840 0076 19        		.byte	25
 2841 0077 1A        		.byte	26
 2842 0078 1B        		.byte	27
 2843 0079 1C        		.byte	28
 2844 007a 1D        		.byte	29
 2845 007b 2F        		.byte	47
 2846 007c 31        		.byte	49
 2847 007d 30        		.byte	48
 2848 007e 35        		.byte	53
 2849 007f 4C        		.byte	76
 2850               		.weak	ascii_to_shift_lut
 2851               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2854               	ascii_to_shift_lut:
 2855 0000 00        		.byte	0
 2856 0001 00        		.byte	0
 2857 0002 00        		.byte	0
 2858 0003 00        		.byte	0
 2859 0004 00        		.byte	0
 2860 0005 00        		.byte	0
 2861 0006 00        		.byte	0
 2862 0007 00        		.byte	0
 2863 0008 00        		.byte	0
 2864 0009 00        		.byte	0
 2865 000a 00        		.byte	0
 2866 000b 00        		.byte	0
 2867 000c 00        		.byte	0
 2868 000d 00        		.byte	0
 2869 000e 00        		.byte	0
 2870 000f 00        		.byte	0
 2871 0010 00        		.byte	0
 2872 0011 00        		.byte	0
 2873 0012 00        		.byte	0
 2874 0013 00        		.byte	0
 2875 0014 00        		.byte	0
 2876 0015 00        		.byte	0
 2877 0016 00        		.byte	0
 2878 0017 00        		.byte	0
 2879 0018 00        		.byte	0
 2880 0019 00        		.byte	0
 2881 001a 00        		.byte	0
 2882 001b 00        		.byte	0
 2883 001c 00        		.byte	0
 2884 001d 00        		.byte	0
 2885 001e 00        		.byte	0
 2886 001f 00        		.byte	0
 2887 0020 00        		.byte	0
 2888 0021 01        		.byte	1
 2889 0022 01        		.byte	1
 2890 0023 01        		.byte	1
 2891 0024 01        		.byte	1
 2892 0025 01        		.byte	1
 2893 0026 01        		.byte	1
 2894 0027 00        		.byte	0
 2895 0028 01        		.byte	1
 2896 0029 01        		.byte	1
 2897 002a 01        		.byte	1
 2898 002b 01        		.byte	1
 2899 002c 00        		.byte	0
 2900 002d 00        		.byte	0
 2901 002e 00        		.byte	0
 2902 002f 00        		.byte	0
 2903 0030 00        		.byte	0
 2904 0031 00        		.byte	0
 2905 0032 00        		.byte	0
 2906 0033 00        		.byte	0
 2907 0034 00        		.byte	0
 2908 0035 00        		.byte	0
 2909 0036 00        		.byte	0
 2910 0037 00        		.byte	0
 2911 0038 00        		.byte	0
 2912 0039 00        		.byte	0
 2913 003a 01        		.byte	1
 2914 003b 00        		.byte	0
 2915 003c 01        		.byte	1
 2916 003d 00        		.byte	0
 2917 003e 01        		.byte	1
 2918 003f 01        		.byte	1
 2919 0040 01        		.byte	1
 2920 0041 01        		.byte	1
 2921 0042 01        		.byte	1
 2922 0043 01        		.byte	1
 2923 0044 01        		.byte	1
 2924 0045 01        		.byte	1
 2925 0046 01        		.byte	1
 2926 0047 01        		.byte	1
 2927 0048 01        		.byte	1
 2928 0049 01        		.byte	1
 2929 004a 01        		.byte	1
 2930 004b 01        		.byte	1
 2931 004c 01        		.byte	1
 2932 004d 01        		.byte	1
 2933 004e 01        		.byte	1
 2934 004f 01        		.byte	1
 2935 0050 01        		.byte	1
 2936 0051 01        		.byte	1
 2937 0052 01        		.byte	1
 2938 0053 01        		.byte	1
 2939 0054 01        		.byte	1
 2940 0055 01        		.byte	1
 2941 0056 01        		.byte	1
 2942 0057 01        		.byte	1
 2943 0058 01        		.byte	1
 2944 0059 01        		.byte	1
 2945 005a 01        		.byte	1
 2946 005b 00        		.byte	0
 2947 005c 00        		.byte	0
 2948 005d 00        		.byte	0
 2949 005e 01        		.byte	1
 2950 005f 01        		.byte	1
 2951 0060 00        		.byte	0
 2952 0061 00        		.byte	0
 2953 0062 00        		.byte	0
 2954 0063 00        		.byte	0
 2955 0064 00        		.byte	0
 2956 0065 00        		.byte	0
 2957 0066 00        		.byte	0
 2958 0067 00        		.byte	0
 2959 0068 00        		.byte	0
 2960 0069 00        		.byte	0
 2961 006a 00        		.byte	0
 2962 006b 00        		.byte	0
 2963 006c 00        		.byte	0
 2964 006d 00        		.byte	0
 2965 006e 00        		.byte	0
 2966 006f 00        		.byte	0
 2967 0070 00        		.byte	0
 2968 0071 00        		.byte	0
 2969 0072 00        		.byte	0
 2970 0073 00        		.byte	0
 2971 0074 00        		.byte	0
 2972 0075 00        		.byte	0
 2973 0076 00        		.byte	0
 2974 0077 00        		.byte	0
 2975 0078 00        		.byte	0
 2976 0079 00        		.byte	0
 2977 007a 00        		.byte	0
 2978 007b 01        		.byte	1
 2979 007c 01        		.byte	1
 2980 007d 01        		.byte	1
 2981 007e 01        		.byte	1
 2982 007f 00        		.byte	0
 2983               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2986               	grave_esc_was_shifted:
 2987 0000 00        		.zero	1
 2988               		.section	.bss.scs_timer,"aw",@nobits
 2991               	scs_timer:
 2992 0000 0000 0000 		.zero	4
 2993               		.section	.bss.shift_interrupted,"aw",@nobits
 2996               	shift_interrupted:
 2997 0000 0000      		.zero	2
 2998               		.text
 2999               	.Letext0:
 3000               		.file 4 "/usr/lib/avr/include/stdint.h"
 3001               		.file 5 "./tmk_core/common/keyboard.h"
 3002               		.file 6 "./tmk_core/common/action.h"
 3003               		.file 7 "./tmk_core/common/report.h"
 3004               		.file 8 "./tmk_core/common/debug.h"
 3005               		.file 9 "quantum/keycode_config.h"
 3006               		.file 10 "./tmk_core/common/keycode.h"
 3007               		.file 11 "quantum/quantum_keycodes.h"
 3008               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 3009               		.file 13 "./lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 3010               		.file 14 "quantum/quantum.h"
 3011               		.file 15 "./tmk_core/common/bootloader.h"
 3012               		.file 16 "./tmk_core/common/action_layer.h"
 3013               		.file 17 "quantum/rgblight.h"
 3014               		.file 18 "quantum/keymap.h"
 3015               		.file 19 "./quantum/process_keycode/process_leader.h"
 3016               		.file 20 "./tmk_core/common/eeconfig.h"
 3017               		.file 21 "./tmk_core/common/timer.h"
 3018               		.file 22 "./tmk_core/common/backlight.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccClBLt4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccClBLt4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccClBLt4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccClBLt4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccClBLt4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccClBLt4.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccClBLt4.s:129    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccClBLt4.s:159    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccClBLt4.s:189    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccClBLt4.s:219    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccClBLt4.s:250    .text.register_code16:0000000000000000 register_code16
     /tmp/ccClBLt4.s:306    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccClBLt4.s:361    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccClBLt4.s:380    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccClBLt4.s:399    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccClBLt4.s:417    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccClBLt4.s:452    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccClBLt4.s:2996   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccClBLt4.s:2986   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccClBLt4.s:2991   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccClBLt4.s:1425   .text.send_char:0000000000000000 send_char
     /tmp/ccClBLt4.s:2721   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccClBLt4.s:2854   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccClBLt4.s:1511   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccClBLt4.s:1655   .text.send_string:0000000000000000 send_string
     /tmp/ccClBLt4.s:1674   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccClBLt4.s:1850   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccClBLt4.s:1869   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccClBLt4.s:1918   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccClBLt4.s:2025   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccClBLt4.s:2152   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccClBLt4.s:2169   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccClBLt4.s:2316   .text.backlight_task:0000000000000000 backlight_task
     /tmp/ccClBLt4.s:2331   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccClBLt4.s:2363   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccClBLt4.s:2383   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccClBLt4.s:2447   .text.send_byte:0000000000000000 send_byte
     /tmp/ccClBLt4.s:2484   .text.send_word:0000000000000000 send_word
     /tmp/ccClBLt4.s:2518   .text.send_dword:0000000000000000 send_dword
     /tmp/ccClBLt4.s:2568   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccClBLt4.s:2607   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccClBLt4.s:2623   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccClBLt4.s:2639   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccClBLt4.s:2657   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccClBLt4.s:2672   .text.led_set:0000000000000000 led_set
     /tmp/ccClBLt4.s:2690   .text.startup_user:0000000000000000 startup_user
     /tmp/ccClBLt4.s:2705   .text.shutdown_user:0000000000000000 shutdown_user

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
process_leader
rgblight_decrease_val
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_decrease_hue
rgblight_increase_hue
rgblight_decrease_sat
rgblight_increase_sat
rgblight_increase_val
rgblight_mode
rgblight_get_mode
timer_read
register_mods
timer_elapsed
unregister_mods
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_on
layer_off
matrix_scan_kb
__umulhisi3
__udivmodsi4
__udivmodhi4
__mulsi3
backlight_init
matrix_init_kb
__do_clear_bss
